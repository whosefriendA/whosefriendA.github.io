<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>推荐系统学习(二)：召回-协同过滤-ItemCF</title>
    <link href="/2026/01/15/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%EF%BC%9A%E5%8F%AC%E5%9B%9E-%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4-ItemCF/"/>
    <url>/2026/01/15/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%EF%BC%9A%E5%8F%AC%E5%9B%9E-%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4-ItemCF/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>再探 WebSocket -不止于全双工</title>
    <link href="/2026/01/08/WebSocket/"/>
    <url>/2026/01/08/WebSocket/</url>
    
    <content type="html"><![CDATA[<p>如果你像我一样，对 HTTP&#x2F;1&#x2F;2&#x2F;3 的演进和 gRPC 的四种调用模式很了解，但谈起 websocket 时认知止于全双工通信，那么 WebSocket 值得我们用同样的视角，重新审视一番。</p><h2 id="参照对比：它与-HTTP-有何不同？和另一个全双工的-gRPC-双向流又有什么区别？"><a href="#参照对比：它与-HTTP-有何不同？和另一个全双工的-gRPC-双向流又有什么区别？" class="headerlink" title="参照对比：它与 HTTP 有何不同？和另一个全双工的 gRPC 双向流又有什么区别？"></a>参照对比：它与 HTTP 有何不同？和另一个全双工的 gRPC 双向流又有什么区别？</h2><h3 id="1-对比-HTTP-1-2-3"><a href="#1-对比-HTTP-1-2-3" class="headerlink" title="1. 对比 HTTP&#x2F;1, 2, 3"></a>1. 对比 HTTP&#x2F;1, 2, 3</h3><p>将 HTTP 简单地描述为“一问一答”不够准确。<br>从基于 HTTP&#x2F;1.1 的 SSE (Server-Sent Events) 到 HTTP&#x2F;2 和 HTTP&#x2F;3 的原生多路复用流，HTTP 已经发展出强大的流式处理能力。</p><p>这些流与 WebSocket 的核心区别在于它们的通信模型：</p><ul><li><p><strong>HTTP 的流是“事务性”的：</strong></p><ul><li>SSE 提供了一个高效的服务器到客户端的单向流，非常适合状态更新和通知推送。但它就像一个广播，客户端无法通过同一连接回话。</li><li>HTTP&#x2F;2 和 HTTP&#x2F;3 的流虽然是双向的，并且可以流式传输数据，但每个流的生命周期和语义都与一次**“请求-响应”**事务绑定。客户端发起请求，服务器给予响应。服务器不能在没有客户端请求的情况下，主动发起一个流来推送消息。</li></ul></li><li><p><strong>WebSocket 的流是“对话式”的：</strong></p><ul><li>WebSocket 在通过 HTTP 握手建立连接后，就完全脱离了 HTTP 的事务模型。整个连接变成了一条持久、对称、全双工的消息通道。</li><li>双方地位完全平等，没有“请求方”和“响应方”之分。任何一方都可以在任何时候主动向对方发送消息。</li></ul></li></ul><h3 id="2-对比gRPC-双向流"><a href="#2-对比gRPC-双向流" class="headerlink" title="2. 对比gRPC 双向流"></a>2. 对比gRPC 双向流</h3><p>gRPC 的双向流和 WebSocket 都是全双工通信，但它们的抽象层次和设计哲学截然不同。我曾经也使用过 RPC 双向流以及 webtransport 来做协同画布这种业务，和使用websocket还是很不同的</p><ul><li><strong>gRPC 双向流:</strong> 每一步都是按照预先定义好的proto。这是一个有上下文、有强类型约束的结构化对话。gRPC 帮你处理了所有的序列化和规则校验，你只用专注于业务逻辑。</li><li><strong>WebSocket:</strong> 不关心通信的内容和格式，只保证二进制数据能清晰、完整地传到对方。你想在上面实现自己的业务逻辑，需要自己定义消息格式（比如用 JSON 或 Protobuf）并维护状态。它提供的是一个无结构、无上下文的通用消息通道。</li></ul><h2 id="WebSocket-的语法、语义与数据格式"><a href="#WebSocket-的语法、语义与数据格式" class="headerlink" title="WebSocket 的语法、语义与数据格式"></a>WebSocket 的语法、语义与数据格式</h2><ul><li><p><strong>语义 (Semantics):</strong> 如前所述，是**面向消息（Message-Oriented）**的。连接一旦建立，通信单元就是一个个独立的“消息”，没有请求和响应的内在关联。</p></li><li><p><strong>语法 (Syntax):</strong> WebSocket 的语法单元是**“帧”（Frame）**。这正是它高效的秘密所在。一次网络传输就是一个或多个帧的组合。一个帧由两部分构成：</p><ul><li>一个二进制帧头（2-14 字节）</li><li>数据载荷（Payload）</li></ul><p>这个二进制帧头里只包含了最基本的信息：这是不是消息的最后一帧（Fin）？是文本（<code>OpCode=1</code>）还是二进制（<code>OpCode=2</code>）？数据有多长？为了安全，从客户端发往服务器的帧，其载荷还会被一个 4 字节的随机密钥进行简单的异或（XOR）“掩码”处理。</p></li><li><p><strong>数据格式 (Data Format):</strong> 这是最关键的一点。WebSocket 帧的帧头 在网络上传输时，就是一个连续的二进制字节流。相比 HTTP&#x2F;1.1 那冗长的纯文本头部，WebSocket 的协议开销（Protocol Overhead）几乎可以忽略不计。每次通信只需付出几个字节的帧头代价，而不是上百字节的 HTTP 头部。而在数据本体方面，websocket是不感知的，可以传文本，也可以传二进制。</p></li></ul><h2 id="对标-HTTPS-的WSS加密"><a href="#对标-HTTPS-的WSS加密" class="headerlink" title="对标 HTTPS 的WSS加密"></a>对标 HTTPS 的WSS加密</h2><p>WSS 的本质是 WebSocket over TLS，与 HTTPS (HTTP over TLS) 的原理完全相同。</p><p>当你使用 <code>wss://</code> 协议头（而非 <code>ws://</code>）时，整个通信流程会增加一个 TLS 安全层：</p><ol><li>在 TCP 连接建立后，应用数据传输之前，客户端和服务器会进行一次完整的 TLS 握手。</li><li>这次握手会验证服务器的证书、协商加密算法，并生成一个临时的对称会话密钥。</li><li>一旦 TLS 握手成功，一条加密通道就建立起来了。</li><li>之后，无论是 WebSocket 的 HTTP 升级握手请求，还是后续的所有 WebSocket 数据帧，都会先经过 TLS 层的加密，然后再在网络上传输。</li></ol><h2 id="WebSocket-Protobuf"><a href="#WebSocket-Protobuf" class="headerlink" title="WebSocket + Protobuf"></a>WebSocket + Protobuf</h2><p><strong>Q:</strong> WebSocket 既然是二进制传输，但它又没有像 gRPC 那样的 IDL，如何处理复杂的结构化数据？</p><p><strong>A:</strong> WebSocket 协议本身不负责定义载荷的内部结构，它只提供高效的传输通道。</p><p>这种需求很符合 Protobuf </p><ul><li><strong>Protobuf 的角色:</strong> 通过 <code>.proto</code> 文件定义数据结构，并能将内存中的对象（Struct）序列化成极其紧凑的二进制字节流。</li><li><strong>WebSocket 的角色:</strong> 接过 Protobuf 打包好的二进制包裹（<code>[]byte</code>），把它放进自己的标准快递箱（二进制帧），然后以极低的成本快速送到目的地。</li></ul><p>这套组合拳对于在线游戏、金融行情推送、实时协作应用等场景非常适用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>初见广告系统-常见概念及单次展示全流程</title>
    <link href="/2026/01/08/%E5%88%9D%E8%A7%81%E5%B9%BF%E5%91%8A%E7%B3%BB%E7%BB%9F-%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8D%95%E6%AC%A1%E5%B1%95%E7%A4%BA%E5%85%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2026/01/08/%E5%88%9D%E8%A7%81%E5%B9%BF%E5%91%8A%E7%B3%BB%E7%BB%9F-%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%8D%95%E6%AC%A1%E5%B1%95%E7%A4%BA%E5%85%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>pCTR :预估点击率<br>pCVR :预估转化率</p><h3 id="1-ecpm-effective-Cost-Per-Mille，有效的千次展示成本"><a href="#1-ecpm-effective-Cost-Per-Mille，有效的千次展示成本" class="headerlink" title="1.ecpm : effective Cost Per Mille，有效的千次展示成本"></a>1.ecpm : effective Cost Per Mille，有效的千次展示成本</h3><p>预估点击率点击出价<br><strong>pCTR</strong> (predicted Click-Through Rate)：模型预估的、这个用户看到这个广告后，点击它的概率。<br>这部分的技术和推荐系统的CTR预估模型几乎完全一样，都使用LR、GBDT、DeepFM、WDL等深度学习模型。<br>模型输入的特征就是用户、广告、上下文的所有信息。<br><strong>Bid_cpc</strong> (Cost Per Click Bid)：广告主为每一次点击愿意支付的最高价格。这是由广告主设定的商业出价。<br>含义：它衡量的是，如果这个广告被展示1000次，平台<strong>预期</strong>能获得多少收入。广告系统会选择eCPM最高的广告进行展示，因为这同时兼顾了<strong>用户兴趣 (pCTR)</strong> 和 <strong>商业价值 (Bid)</strong>。一个用户再喜欢某个广告（pCTR高），如果广告主不出钱（Bid低），eCPM也会很低，广告也排不上去。</p><h3 id="2-RTA"><a href="#2-RTA" class="headerlink" title="2.RTA"></a>2.RTA</h3><p>RTA (Real-time API) 是一种技术接口，它允许<strong>广告主</strong>在广告平台进行<strong>实时竞价</strong>的瞬间，利用其<strong>第一方私有数据</strong>参与投放决策。本质上，是广告平台在最终排序前，向广告主服务器发起的一次实时问询，赋予广告主对单次曝光的“一票否决权”和“动态调价权”。<br>作用：<strong>利用第一方数据</strong><br><strong>精细化用户生命周期管理</strong><br><strong>数据安全与隐私保护</strong><br><strong>实时预算与风控</strong></p><h3 id="3-RTB"><a href="#3-RTB" class="headerlink" title="3. RTB"></a>3. RTB</h3><h3 id="4-头部竞价"><a href="#4-头部竞价" class="headerlink" title="4. 头部竞价"></a>4. 头部竞价</h3><p>传统媒体变现采用“<strong>瀑布流</strong>”(Waterfall)模式，即按预设顺序依次请求广告网络，一旦某个网络返回广告就成交。这种模式的弊端是：排在后面的广告网络即使出价更高，也可能没有机会参与竞价，导致媒体收益损失。<br>而头部竞价则是：</p><ol><li><strong>并行询价：</strong> 在向主广告交易平台(Ad Exchange)发送请求前，媒体网站&#x2F;App的前端代码（Header部分）会同时向多个广告需求方（SSP&#x2F;DSP）发起竞价请求。</li><li><strong>收集出价：</strong> 在一个极短的超时时间内（如200ms），收集所有参与方的出价。</li><li><strong>传递胜者：</strong> 将最高出价作为“底价”或一个特殊的竞价参数，传递给主广告交易平台，让这个“场外最高价”与场内广告进行最终PK。</li></ol><h3 id="5-DSP-DMP-CMP-SSP等核心组件"><a href="#5-DSP-DMP-CMP-SSP等核心组件" class="headerlink" title="5.DSP,DMP,CMP,SSP等核心组件"></a>5.DSP,DMP,CMP,SSP等核心组件</h3><p><img src="/image.png" alt="alt text"></p><p><strong>0. 头部竞价</strong><br><strong>1. 广告请求 (Ad Request)</strong></p><ul><li><strong>触发：</strong> 用户设备（App&#x2F;网页）即将展示广告位时。</li><li><strong>任务：</strong> 向广告平台发送请求，携带关键上下文信息。</li><li><strong>关键信息：</strong>- &#x3D;<strong>用户 (User)：</strong> 用户画像标签（年龄、性别、兴趣）、设备ID。<ul><li><strong>环境 (Context)：</strong> 时间、IP地址（地理位置）、网络类型、当前浏览内容。</li><li><strong>广告位 (Placement)：</strong> 广告位ID、尺寸、类型（如信息流、开屏）。</li></ul></li></ul><p><strong>2. 检索与定向 (Retrieval &amp; Targeting)</strong></p><ul><li><strong>任务：</strong> 从海量广告库中，快速筛选出符合本次请求条件的<strong>候选广告集</strong>（百&#x2F;千量级）。类似推荐系统的“召回”。</li><li><strong>核心技术&#x2F;策略 (定向方式)：</strong>- <strong>基础定向：</strong> 人口属性、地理位置、设备等。<ul><li><strong>兴趣&#x2F;行为定向：</strong> 基于用户历史行为（点击、浏览、搜索）匹配广告。</li><li><strong>重定向 (Retargeting)：</strong> 针对访问过广告主网站或App的用户进行再次营销。</li><li><strong>人群扩展 (Lookalike)：</strong> 寻找与广告主已有高价值用户相似的人群。</li></ul></li></ul><p><strong>3.RTA（可选）</strong><br><strong>4. 排序 (Ranking)</strong></p><ul><li><strong>任务：</strong> 对候选广告集进行精准打分和排序，选出最优广告。这是广告系统的技术<strong>核心</strong>。<br>  <strong>核心公式：eCPM:</strong></li><li>公式解析：** pCTR** (预估点击率)： 通过机器学习模型（如DeepFM）预测“该用户点击该广告”的概率。<strong>衡量用户兴趣</strong>。<ul><li><strong>Bid_cpc (点击出价)：</strong> 广告主为单次点击愿意支付的最高价格。<strong>衡量商业价值</strong>。</li></ul></li><li><strong>排序</strong>逻辑**：** 系统按 eCPM 从高到低排序，eCPM 最高的广告胜出。这确保了<strong>用户兴趣</strong>和<strong>商业价值</strong>的综合最优。</li><li>可选策略 1：<strong>智能出价 <strong>(oCPX &#x2F; Smart Bidding)</strong>- <strong>工作流： 广告主不再设定固定的<code>Bid</code>，而是设定一个转化目标成本（如CPA）。平台通过</strong>pCVR（预估转化率）模型</strong>自动反推出价。<ul><li><strong>公式演变：****<code>eCPM = pCTR × (pCVR × CPA_target) × 1000</code></strong>(以oCPC为例)</li><li><strong>作用：</strong> 投放目标从“买量”转向“买效果”，将优化目标与广告主业务目标对齐，是目前的主流投放方式。</li></ul></li><li>可选策略 2：动态创意优化 <strong>(DCO)</strong> - Dynamic Creative Optimization - 工作流： 系统不再投放一个固定的“成品”广告，而是拥有一个“创意元素库”（如多张图片、多个标题、多个按钮文案）。在排序时，系统会实时组合这些元素，并预估<strong>哪个组合的pCTR最高</strong>，然后用该组合参与竞价。<ul><li><strong>作用：</strong> 实现“千人千面”的广告创意，极大提升点击率和用户体验。</li></ul></li></ul><p><strong>5. 竞价与计费 (Auction &amp; Pricing)</strong></p><ul><li><strong>任务：</strong> 确定最终胜出的广告及其需要支付的费用。</li><li><strong>核心机制：GSP (广义第二价格拍卖)</strong>- <strong>竞价胜者：</strong> eCPM 排名第一的广告获得展示机会。<ul><li><strong>计费规则：胜者需要支付的实际点击价格(Actual CPC)，是</strong>刚好能以微弱优势战胜第二名eCPM所需要的价格。<br>  <strong><code>Actual_CPC_1 = (eCPM_2 / pCTR_1) + 0.01</code></strong></li><li><strong>目的：</strong> 鼓励广告主写真实出价，维持系统稳定性。</li></ul></li><li>可选其他策略：第一价格拍卖</li></ul><p><strong>6. 展示与反馈 (Display &amp; Feedback Loop)</strong></p><ul><li><strong>任务：</strong> 将胜出的广告返回给用户设备进行展示，并收集后续行为数据，形成闭环。</li><li><strong>行为记录：</strong>- <strong>展示 (Impression)：</strong> 广告被成功加载。<ul><li><strong>点击 (Click)：</strong> 用户点击广告。</li><li><strong>转化 (Conversion)：</strong> 用户完成广告主期望的后续行为（如下载、注册、购买）。</li></ul></li><li><strong>闭环作用：</strong> 收集到的真实数据（展示、点击、转化）将作为<strong>训练样本</strong>，用于迭代和优化 <strong>pCTR&#x2F;pCVR</strong>（预估转化率）等机器学习模型，使预估越来越准，从而提升整个系统的效率和收入。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch入门使用</title>
    <link href="/2025/12/15/Elasticsearch%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/12/15/Elasticsearch%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>#ES的部分原理</p><h3 id="默认打分规则"><a href="#默认打分规则" class="headerlink" title="默认打分规则"></a>默认打分规则</h3><p><strong>默认相关性评分 (Relevance Score)</strong>：<br>默认使用 <strong>BM25 算法</strong>（可以看作是 TF-IDF 的升级版）。它会综合考虑：</p><ul><li><strong>词频 (Term Frequency)</strong>：关键词在文档中出现的次数。</li><li><strong>逆文档频率 (Inverse Document Frequency)</strong>：关键词在所有文档中的稀有程度。</li><li><strong>字段长度 (Field Length)</strong>：字段越短，匹配到的权重越高。</li></ul><p>#ES的使用<br>##索引库操作<br>索引库就类似数据库表，mapping映射就类似表的结构。<br>我们要向es中存储数据，必须先创建“库”和“表”。</p><h3 id="1-Mapping映射属性"><a href="#1-Mapping映射属性" class="headerlink" title="1. Mapping映射属性"></a>1. Mapping映射属性</h3><p>mapping是对索引库中文档的约束，常见的mapping属性包括：</p><ul><li>type：字段数据类型，常见的简单类型有：<ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）<blockquote><p><strong>keyword类型只能整体搜索，不支持搜索部分内容</strong></p></blockquote></li><li>数值：long、integer、short、byte、double、float、</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li></ul></li><li>index：是否创建索引，默认为true</li><li>analyzer：使用哪种分词器</li><li>properties：该字段的子字段</li></ul><p>例如下面的json文档：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">21</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">52.1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;isMarried&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;真相只有一个！&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;zy@itcast.cn&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;score&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-number">99.1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">99.5</span><span class="hljs-punctuation">,</span> <span class="hljs-number">98.9</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;柯&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;南&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>对应的每个字段映射（mapping）：</p><ul><li>age：类型为 integer；参与搜索，因此需要index为true；无需分词器</li><li>weight：类型为float；参与搜索，因此需要index为true；无需分词器</li><li>isMarried：类型为boolean；参与搜索，因此需要index为true；无需分词器</li><li>info：类型为字符串，需要分词，因此是text；参与搜索，因此需要index为true；分词器可以用ik_smart</li><li>email：类型为字符串，但是不需要分词，因此是keyword；不参与搜索，因此需要index为false；无需分词器</li><li>score：虽然是数组，但是我们只看元素的类型，类型为float；参与搜索，因此需要index为true；无需分词器</li><li>name：类型为object，需要定义多个子属性- name.firstName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器<ul><li>name.lastName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器</li></ul></li></ul><h3 id="2-索引库的CRUD"><a href="#2-索引库的CRUD" class="headerlink" title="2. 索引库的CRUD"></a>2. 索引库的CRUD</h3><blockquote><p>CRUD简单描述：</p></blockquote><ul><li>创建索引库：PUT &#x2F;索引库名</li><li>查询索引库：GET &#x2F;索引库名</li><li>删除索引库：DELETE &#x2F;索引库名</li><li>修改索引库（添加字段）：PUT &#x2F;索引库名&#x2F;_mapping</li></ul><p>这里统一使用Kibana编写DSL的方式来演示。</p><h4 id="2-1-创建索引库和映射"><a href="#2-1-创建索引库和映射" class="headerlink" title="2.1 创建索引库和映射"></a>2.1 创建索引库和映射</h4><p><strong>基本语法：</strong></p><ul><li>请求方式：PUT</li><li>请求路径：&#x2F;索引库名，可以自定义</li><li>请求参数：mapping映射</li></ul><p>格式：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">PUT</span> /索引库名称<br>&#123;<br>  <span class="hljs-string">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;字段名&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-string">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_smart&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;字段名2&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-string">&quot;false&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;字段名3&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;子字段&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>          &#125;<br>        &#125;<br>      &#125;,<br>      <span class="hljs-comment">// ...略</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">PUT <span class="hljs-string">/conan</span><br>&#123;<br>  <span class="hljs-string">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;column1&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-string">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_smart&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;column2&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-string">&quot;false&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;column3&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;子字段1&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>          &#125;,<br>          <span class="hljs-string">&quot;子字段2&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>          &#125;<br>        &#125;<br>      &#125;,<br>      <span class="hljs-string">//</span> <span class="hljs-string">...</span>略<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-查询索引库"><a href="#2-2-查询索引库" class="headerlink" title="2.2 查询索引库"></a>2.2 查询索引库</h4><p><strong>基本语法</strong>：</p><ul><li>请求方式：GET</li><li>请求路径：&#x2F;索引库名</li><li>请求参数：无</li></ul><p><strong>格式</strong>：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /索引库名<br></code></pre></td></tr></table></figure><h4 id="2-3-修改索引库"><a href="#2-3-修改索引库" class="headerlink" title="2.3 修改索引库"></a>2.3 修改索引库</h4><blockquote><p>这里的修改是只能增加新的字段到mapping中</p></blockquote><p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库<strong>一旦创建，无法修改mapping</strong>。<br>虽然无法修改mapping中已有的字段，但是却<strong>允许添加新的字段</strong>到mapping中，因为不会对倒排索引产生影响。<br><strong>语法说明</strong>：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">PUT <span class="hljs-regexp">/索引库名/</span>_mapping<br>&#123;<br>  <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;新字段名&quot;</span>:&#123;<br>      <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-删除索引库"><a href="#2-4-删除索引库" class="headerlink" title="2.4 删除索引库"></a>2.4 删除索引库</h4><p><strong>语法：</strong></p><ul><li>请求方式：DELETE</li><li>请求路径：&#x2F;索引库名</li><li>请求参数：无</li></ul><p><strong>格式：</strong></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">DELETE</span> /索引库名<br></code></pre></td></tr></table></figure><h2 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h2><blockquote><p>文档操作有哪些？</p></blockquote><ul><li>创建文档：POST &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id</li><li>查询文档：GET &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id</li><li>删除文档：DELETE &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id</li><li>修改文档：- 全量修改：PUT &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id<ul><li>增量修改：POST &#x2F;{索引库名}&#x2F;_update&#x2F;文档id { “doc”: {字段}}</li></ul></li></ul><h3 id="1-文档的CRUD"><a href="#1-文档的CRUD" class="headerlink" title="1. 文档的CRUD"></a>1. 文档的CRUD</h3><h4 id="1-1-新增文档"><a href="#1-1-新增文档" class="headerlink" title="1.1 新增文档"></a>1.1 新增文档</h4><p><strong>语法：</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">POST /索引库名<span class="hljs-string">/_doc/</span>文档id<br>&#123;<br>    <span class="hljs-string">&quot;字段1&quot;</span>: <span class="hljs-string">&quot;值1&quot;</span>,<br>    <span class="hljs-string">&quot;字段2&quot;</span>: <span class="hljs-string">&quot;值2&quot;</span>,<br>    <span class="hljs-string">&quot;字段3&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;子属性1&quot;</span>: <span class="hljs-string">&quot;值3&quot;</span>,<br>        <span class="hljs-string">&quot;子属性2&quot;</span>: <span class="hljs-string">&quot;值4&quot;</span><br>    &#125;,<br>    <span class="hljs-string">//</span> <span class="hljs-string">...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">POST <span class="hljs-regexp">/heima/</span>_doc/<span class="hljs-number">1</span><br>&#123;<br>    <span class="hljs-string">&quot;info&quot;</span>: <span class="hljs-string">&quot;真相只有一个！&quot;</span>,<br>    <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;zy@itcast.cn&quot;</span>,<br>    <span class="hljs-string">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;firstName&quot;</span>: <span class="hljs-string">&quot;柯&quot;</span>,<br>        <span class="hljs-string">&quot;lastName&quot;</span>: <span class="hljs-string">&quot;南&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-查询文档"><a href="#1-2-查询文档" class="headerlink" title="1.2 查询文档"></a>1.2 查询文档</h4><p>根据rest风格，新增是post，查询应该是get，不过查询一般都需要条件，这里我们把文档id带上。<br><strong>语法：</strong></p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">GET</span> /&#123;索引库名称&#125;/<span class="hljs-variable">_doc</span>/&#123;id&#125;<br><span class="hljs-comment">//批量查询：查询该索引库下的全部文档</span><br><span class="hljs-built_in">GET</span> /&#123;索引库名称&#125;/<span class="hljs-variable">_search</span><br></code></pre></td></tr></table></figure><p><strong>通过kibana查看数据：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /heima/_doc/1<br></code></pre></td></tr></table></figure><h4 id="1-3-删除文档"><a href="#1-3-删除文档" class="headerlink" title="1.3 删除文档"></a>1.3 删除文档</h4><p>删除使用DELETE请求，同样，需要根据id进行删除：<br><strong>语法：</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">DELETE</span> <span class="hljs-regexp">/&#123;索引库名&#125;/</span>_doc/id值<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 根据id删除数据</span><br><span class="hljs-attribute">DELETE</span> /heima/_doc/<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="1-4-修改文档"><a href="#1-4-修改文档" class="headerlink" title="1.4 修改文档"></a>1.4 修改文档</h4><p>修改有两种方式：</p><ul><li>全量修改：直接覆盖原来的文档</li><li>增量修改：修改文档中的部分字段</li></ul><h5 id="1-4-1-全量修改"><a href="#1-4-1-全量修改" class="headerlink" title="1.4.1 全量修改"></a>1.4.1 全量修改</h5><p>全量修改是覆盖原来的文档，其本质是：</p><ul><li>根据指定的id删除文档</li><li>新增一个相同id的文档</li></ul><p><strong>注意</strong>：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。<br><strong>语法：</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">PUT /&#123;索引库名&#125;<span class="hljs-string">/_doc/</span>文档id<br>&#123;<br>    <span class="hljs-string">&quot;字段1&quot;</span>: <span class="hljs-string">&quot;值1&quot;</span>,<br>    <span class="hljs-string">&quot;字段2&quot;</span>: <span class="hljs-string">&quot;值2&quot;</span>,<br>    <span class="hljs-string">//</span> <span class="hljs-string">...</span> 略<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">PUT <span class="hljs-regexp">/heima/</span>_doc/<span class="hljs-number">1</span><br>&#123;<br>    <span class="hljs-string">&quot;info&quot;</span>: <span class="hljs-string">&quot;黑马程序员高级Java讲师&quot;</span>,<br>    <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;zy@itcast.cn&quot;</span>,<br>    <span class="hljs-string">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;firstName&quot;</span>: <span class="hljs-string">&quot;云&quot;</span>,<br>        <span class="hljs-string">&quot;lastName&quot;</span>: <span class="hljs-string">&quot;赵&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-4-2-增量修改"><a href="#1-4-2-增量修改" class="headerlink" title="1.4.2 增量修改"></a>1.4.2 增量修改</h5><p>增量修改是只修改指定id匹配的文档中的部分字段。<br><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">POST /&#123;索引库名&#125;/_update/文档<span class="hljs-built_in">id</span><br>&#123;<br>    <span class="hljs-string">&quot;doc&quot;</span>: &#123;<br>         <span class="hljs-string">&quot;字段名&quot;</span>: <span class="hljs-string">&quot;新的值&quot;</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">POST <span class="hljs-regexp">/heima/</span>_update/<span class="hljs-number">1</span><br>&#123;<br>  <span class="hljs-string">&quot;doc&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;ZhaoYun@itcast.cn&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="DSL基本使用"><a href="#DSL基本使用" class="headerlink" title="DSL基本使用"></a>DSL基本使用</h1><h3 id="第二部分：在-Kibana-中编写-DSL-的基本语法"><a href="#第二部分：在-Kibana-中编写-DSL-的基本语法" class="headerlink" title="第二部分：在 Kibana 中编写 DSL 的基本语法"></a>第二部分：在 Kibana 中编写 DSL 的基本语法</h3><p>Kibana 的 <strong>Dev Tools (开发工具)</strong> 提供了一个控制台，可以让你直接编写和发送 DSL 查询给 Elasticsearch。</p><h4 id="1-基本查询结构"><a href="#1-基本查询结构" class="headerlink" title="1. 基本查询结构"></a>1. 基本查询结构</h4><p>一个典型的搜索请求结构如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">GET</span> /your_index_name/<span class="hljs-variable">_search</span><br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-comment">// 查询子句放在这里</span><br>  &#125;,<br>  <span class="hljs-comment">// 其他选项，如排序、分页、聚合等</span><br>  <span class="hljs-string">&quot;from&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">10</span>,<br>  <span class="hljs-string">&quot;sort&quot;</span>: [<br>    &#123; <span class="hljs-string">&quot;timestamp&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span> &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>GET /your_index_name/_search</code>: 请求方法是 <code>GET</code>，路径是你的索引名加上 <code>_search</code> 端点。</li><li><code>query</code>: 最核心的部分，定义了你的搜索条件。</li><li><code>from</code>: 从第几条结果开始返回，用于分页（从0开始）。</li><li><code>size</code>: 返回多少条结果，用于分页。</li><li><code>sort</code>: 定义结果的排序规则。</li></ul><h3 id="2-常用查询子句-Query-Clauses"><a href="#2-常用查询子句-Query-Clauses" class="headerlink" title="2. 常用查询子句 (Query Clauses)"></a>2. 常用查询子句 (Query Clauses)</h3><h5 id="a-match-all-匹配所有文档"><a href="#a-match-all-匹配所有文档" class="headerlink" title="a. match_all: 匹配所有文档"></a>a. <code>match_all</code>: 匹配所有文档</h5><p>最简单的查询，返回索引中的所有文档。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /logs/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="b-match-全文搜索"><a href="#b-match-全文搜索" class="headerlink" title="b. match: 全文搜索"></a>b. <code>match</code>: 全文搜索</h5><p>用于标准的全文搜索。它会先对查询字符串进行<strong>分词 (Analyze)</strong>，然后去匹配分词后的词条。</p><ul><li><strong>场景</strong>: 搜索日志消息或文章内容。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /logs/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;match&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;connect to database&quot;</span> <br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个查询会找到 <code>message</code> 字段中包含 “connect”、”to” 或 “database” 的文档，并根据相关性评分排序。</p><h5 id="c-multi-match-多字段全文搜索"><a href="#c-multi-match-多字段全文搜索" class="headerlink" title="c. multi_match: 多字段全文搜索"></a>c. <code>multi_match</code>: 多字段全文搜索</h5><p><code>match</code> 查询的升级版，允许你用<strong>一个关键词同时搜索多个字段</strong>。</p><ul><li><strong>场景</strong>: 在电商网站搜索“笔记本电脑”，希望同时匹配商品 <code>title</code> 和 <code>description</code> 字段。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /products/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;multi_match&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;query&quot;</span>: <span class="hljs-string">&quot;笔记本电脑&quot;</span>,<br>      <span class="hljs-string">&quot;fields&quot;</span>: [<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;description&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="d-match-phrase-短语匹配"><a href="#d-match-phrase-短语匹配" class="headerlink" title="d. match_phrase: 短语匹配"></a>d. <code>match_phrase</code>: 短语匹配</h5><p>与 <code>match</code> 不同，它要求所有词条必须以<strong>相同的顺序</strong>紧邻出现。</p><ul><li><strong>场景</strong>: 搜索一个完整的句子或特定短语，例如 “真相只有一个”。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /conan/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;match_phrase&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;info&quot;</span>: <span class="hljs-string">&quot;真相只有一个&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="e-term-精确匹配"><a href="#e-term-精确匹配" class="headerlink" title="e. term: 精确匹配"></a>e. <code>term</code>: 精确匹配</h5><p>用于匹配<strong>未经分词</strong>的精确值。通常用于 <code>keyword</code>、<code>integer</code>、<code>boolean</code> 等类型的字段。</p><ul><li><strong>场景</strong>: 查找特定状态码、标签或ID。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /logs/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;term&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;level.keyword&quot;</span>: <span class="hljs-string">&quot;ERROR&quot;</span> <br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>: 如果字段类型是 <code>text</code>，它会被分词。例如 “user-service” 可能会被分成 “user” 和 “service”。如果你想对整个 “user-service” 进行精确匹配，需要查询它的 <code>.keyword</code> 子字段（如果 mapping 中定义了的话）。</p><h5 id="f-terms-多个精确匹配-OR"><a href="#f-terms-多个精确匹配-OR" class="headerlink" title="f. terms: 多个精确匹配 (OR)"></a>f. <code>terms</code>: 多个精确匹配 (OR)</h5><p><code>term</code> 的复数形式，匹配字段值在给定数组中的任意一个。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /logs/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;terms&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;service.keyword&quot;</span>: [<span class="hljs-string">&quot;user-service&quot;</span>, <span class="hljs-string">&quot;order-service&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="g-range-范围查询"><a href="#g-range-范围查询" class="headerlink" title="g. range: 范围查询"></a>g. <code>range</code>: 范围查询</h5><p>用于数字、日期或字符串范围的查询。</p><ul><li><code>gt</code>: 大于 (greater than)</li><li><code>gte</code>: 大于等于 (greater than or equal to)</li><li><code>lt</code>: 小于 (less than)</li><li><code>lte</code>: 小于等于 (less than or equal to)</li></ul><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sqf">json复制<span class="hljs-built_in">GET</span> /logs/<span class="hljs-variable">_search</span><br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;range&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;timestamp&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;gte&quot;</span>: <span class="hljs-string">&quot;now-1h&quot;</span>, <span class="hljs-comment">// 大于等于1小时前</span><br>        <span class="hljs-string">&quot;lt&quot;</span>: <span class="hljs-string">&quot;now&quot;</span>      <span class="hljs-comment">// 小于现在</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="h-bool-组合查询-布尔查询"><a href="#h-bool-组合查询-布尔查询" class="headerlink" title="h. bool: 组合查询 (布尔查询)"></a>h. <code>bool</code>: 组合查询 (布尔查询)</h5><p>这是最强大、最常用的查询。它允许你将多个查询子句组合起来，实现复杂的逻辑。</p><ul><li><code>must</code>: <strong>AND</strong> 逻辑。所有子句都必须匹配，并且会计算相关性得分。</li><li><code>should</code>: <strong>OR</strong> 逻辑。至少有一个子句需要匹配。</li><li><code>must_not</code>: <strong>NOT</strong> 逻辑。所有子句都不能匹配。</li><li><code>filter</code>: <strong>AND</strong> 逻辑，但它在“过滤上下文”中执行。它<strong>不计算相关性得分</strong>，并且结果可以被缓存，因此<strong>性能更高</strong>。非常适合用于精确匹配的过滤条件。</li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-symbol">GET</span> /logs/<span class="hljs-symbol">_search</span><br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;bool&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;must&quot;</span>: [<br>        &#123; <span class="hljs-string">&quot;match&quot;</span>: &#123; <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;database&quot;</span> &#125; &#125;<br>      ],<br>      <span class="hljs-string">&quot;filter&quot;</span>: [<br>        &#123; <span class="hljs-string">&quot;term&quot;</span>:  &#123; <span class="hljs-string">&quot;level.keyword&quot;</span>: <span class="hljs-string">&quot;ERROR&quot;</span> &#125; &#125;,<br>        &#123; <span class="hljs-string">&quot;range&quot;</span>: &#123; <span class="hljs-string">&quot;timestamp&quot;</span>: &#123; <span class="hljs-string">&quot;gte&quot;</span>: <span class="hljs-string">&quot;now-24h&quot;</span> &#125; &#125; &#125;<br>      ]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-进阶查询与相关性控制"><a href="#3-进阶查询与相关性控制" class="headerlink" title="3. 进阶查询与相关性控制"></a>3. 进阶查询与相关性控制</h3><p>以下查询子句提供了更精细的控制能力，用于优化搜索结果的相关性或处理特殊场景。</p><h5 id="a-function-score-自定义相关性得分"><a href="#a-function-score-自定义相关性得分" class="headerlink" title="a. function_score: 自定义相关性得分"></a>a. <code>function_score</code>: 自定义相关性得分</h5><p>这是 Elasticsearch 的一个核心高级功能，它允许你<strong>修改</strong>一个查询产生的原始 <code>_score</code>。你可以引入业务相关的因子来影响最终排序。</p><ul><li><strong>场景</strong>:1. 新发布的文章应该有更高的排名。<ol start="2"><li>点赞数、评论数越多的商品，排名越靠前。</li><li>距离用户当前位置越近的店铺，排名越靠前。</li></ol></li></ul><p>下面的例子中，我们在 <code>match</code> 查询的基础上，将文档的 <code>likes</code> (点赞数) 作为一个因子来提升最终得分。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /articles/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;function_score&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;query&quot;</span>: &#123; <span class="hljs-string">&quot;match&quot;</span>: &#123; <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;elasticsearch&quot;</span> &#125; &#125;,<br>      <span class="hljs-string">&quot;field_value_factor&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;field&quot;</span>: <span class="hljs-string">&quot;likes&quot;</span>,<br>        <span class="hljs-string">&quot;modifier&quot;</span>: <span class="hljs-string">&quot;log1p&quot;</span>,<br>        <span class="hljs-string">&quot;factor&quot;</span>: 0.1<br>      &#125;,<br>      <span class="hljs-string">&quot;boost_mode&quot;</span>: <span class="hljs-string">&quot;sum&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="b-boosting-降权查询"><a href="#b-boosting-降权查询" class="headerlink" title="b. boosting: 降权查询"></a>b. <code>boosting</code>: 降权查询</h5><p>当你需要匹配一些内容，但希望其中某些特定条件会<strong>降低</strong>其相关性得分时使用。</p><ul><li><strong>场景</strong>: 搜索“苹果”，但希望包含“手机壳”的文档排名靠后一些。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /products/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;boosting&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;positive&quot;</span>: &#123; <span class="hljs-string">&quot;match&quot;</span>: &#123; <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;苹果&quot;</span> &#125; &#125;,<br>      <span class="hljs-string">&quot;negative&quot;</span>: &#123; <span class="hljs-string">&quot;match&quot;</span>: &#123; <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;手机壳&quot;</span> &#125; &#125;,<br>      <span class="hljs-string">&quot;negative_boost&quot;</span>: 0.2<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="c-prefix-和-wildcard-前缀与通配符查询"><a href="#c-prefix-和-wildcard-前缀与通配符查询" class="headerlink" title="c. prefix 和 wildcard: 前缀与通配符查询"></a>c. <code>prefix</code> 和 <code>wildcard</code>: 前缀与通配符查询</h5><ul><li><code>prefix</code>: 查找以特定前缀开头的词条。</li><li><code>wildcard</code>: 使用 <code>*</code> 和 <code>?</code> 进行通配符匹配。</li><li><strong>场景</strong>: 用于搜索建议、自动补全或不确定的模式匹配。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /users/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;prefix&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;username.keyword&quot;</span>: <span class="hljs-string">&quot;admin&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>性能警告</strong>: 这两种查询（尤其是 <code>wildcard</code>）会消耗大量资源，因为它们需要扫描索引中的大量词条。除非必要，否则应避免在用户输入的查询中</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>推荐系统学习(一)：召回-协同过滤-UserCF</title>
    <link href="/2025/12/11/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-%E4%B8%80-%EF%BC%9A%E5%8F%AC%E5%9B%9E-%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4-UserCF/"/>
    <url>/2025/12/11/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-%E4%B8%80-%EF%BC%9A%E5%8F%AC%E5%9B%9E-%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4-UserCF/</url>
    
    <content type="html"><![CDATA[<h2 id="基于用户的协同过滤-userCF"><a href="#基于用户的协同过滤-userCF" class="headerlink" title="基于用户的协同过滤(userCF)"></a>基于用户的协同过滤(userCF)</h2><h4 id="第一步：用户相似度计算"><a href="#第一步：用户相似度计算" class="headerlink" title="第一步：用户相似度计算"></a>第一步：用户相似度计算</h4><h5 id="杰卡德相似系数"><a href="#杰卡德相似系数" class="headerlink" title="杰卡德相似系数"></a>杰卡德相似系数</h5><p>被推荐用户A，另一个用户B，只计算他们共同 item 数 占 A item 数 的比值。公式表现为：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">w<span class="hljs-built_in">_</span>&#123;uv&#125; = <span class="hljs-keyword">\frac</span>&#123;|N(u) <span class="hljs-keyword">\cap</span> N(v)|&#125;&#123;|N(u) <span class="hljs-keyword">\cup</span> N(v)|&#125;<br></code></pre></td></tr></table></figure><h5 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h5><p>通过向量化表示用户，对两个用户求向量夹角，可以体现出两个人兴趣方向是否相似，相比于杰卡德系数消除了热点造成的影响。在transformer里也有类似的求向量相似度，不过是使用比较简单的点积而非余弦。余弦相似度的公式是：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">w<span class="hljs-built_in">_</span>&#123;uv&#125; = <span class="hljs-keyword">\frac</span>&#123;|N(u) <span class="hljs-keyword">\cap</span> N(v)|&#125;&#123;<span class="hljs-keyword">\sqrt</span>&#123;|N(u)|<span class="hljs-keyword">\cdot</span>|N(v)|&#125;&#125;<br></code></pre></td></tr></table></figure><p>上面是集合形式的表达，由于喜欢，不喜欢是二元向量，所以可以如上表达，真正的余弦相似度公式是：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\text</span>&#123;similarity&#125; = <span class="hljs-keyword">\cos</span>(<span class="hljs-keyword">\theta</span>) = <span class="hljs-keyword">\frac</span>&#123;A <span class="hljs-keyword">\cdot</span> B&#125;&#123;<span class="hljs-keyword">\|</span>A<span class="hljs-keyword">\|</span> <span class="hljs-keyword">\|</span>B<span class="hljs-keyword">\|</span>&#125;<br></code></pre></td></tr></table></figure><h5 id="皮尔逊相关系数"><a href="#皮尔逊相关系数" class="headerlink" title="皮尔逊相关系数"></a>皮尔逊相关系数</h5><p>有具体评分而不是只有二元关系时使用，可以去除每个人打分标准不同导致的误差。公式：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">w<span class="hljs-built_in">_</span>&#123;uv&#125; = <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;i <span class="hljs-keyword">\in</span> I&#125;(r<span class="hljs-built_in">_</span>&#123;ui&#125; - <span class="hljs-keyword">\bar</span>&#123;r&#125;<span class="hljs-built_in">_</span>u)(r<span class="hljs-built_in">_</span>&#123;vi&#125; - <span class="hljs-keyword">\bar</span>&#123;r&#125;<span class="hljs-built_in">_</span>v)&#125;&#123;<span class="hljs-keyword">\sqrt</span>&#123;<span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;i <span class="hljs-keyword">\in</span> I&#125;(r<span class="hljs-built_in">_</span>&#123;ui&#125; - <span class="hljs-keyword">\bar</span>&#123;r&#125;<span class="hljs-built_in">_</span>u)<span class="hljs-built_in">^</span>2&#125;<span class="hljs-keyword">\sqrt</span>&#123;<span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;i <span class="hljs-keyword">\in</span> I&#125;(r<span class="hljs-built_in">_</span>&#123;vi&#125; - <span class="hljs-keyword">\bar</span>&#123;r&#125;<span class="hljs-built_in">_</span>v)<span class="hljs-built_in">^</span>2&#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="第二步：-候选物品推荐"><a href="#第二步：-候选物品推荐" class="headerlink" title="第二步： 候选物品推荐"></a>第二步： 候选物品推荐</h4><h5 id="简单加权平均"><a href="#简单加权平均" class="headerlink" title="简单加权平均"></a>简单加权平均</h5><p>直接用第一步得到的相似度来加权计算，然后多个用户的值平均，就是被推荐用户 u 对这个物品 p 的预测评分,公式：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\hat</span>&#123;r&#125;<span class="hljs-built_in">_</span>&#123;u,p&#125; = <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;v <span class="hljs-keyword">\in</span> S<span class="hljs-built_in">_</span>u&#125; w<span class="hljs-built_in">_</span>&#123;uv&#125; <span class="hljs-keyword">\,</span> r<span class="hljs-built_in">_</span>&#123;v,p&#125;&#125;&#123;<span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;v <span class="hljs-keyword">\in</span> S<span class="hljs-built_in">_</span>u&#125; w<span class="hljs-built_in">_</span>&#123;uv&#125;&#125;<br></code></pre></td></tr></table></figure><h5 id="考虑评分偏置"><a href="#考虑评分偏置" class="headerlink" title="考虑评分偏置"></a>考虑评分偏置</h5><p>考虑其他用户的平均评分来减少误差，并根据目标用户的平均评分进行调整，公式：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\hat</span>&#123;r&#125;<span class="hljs-built_in">_</span>&#123;u,p&#125; = <span class="hljs-keyword">\bar</span>&#123;r&#125;<span class="hljs-built_in">_</span>&#123;u&#125; + <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;v <span class="hljs-keyword">\in</span> S<span class="hljs-built_in">_</span>u&#125; w<span class="hljs-built_in">_</span>&#123;uv&#125; <span class="hljs-keyword">\,</span> (r<span class="hljs-built_in">_</span>&#123;v,p&#125; - <span class="hljs-keyword">\bar</span>&#123;r&#125;<span class="hljs-built_in">_</span>&#123;v&#125;)&#125;&#123;<span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;v <span class="hljs-keyword">\in</span> S<span class="hljs-built_in">_</span>u&#125; w<span class="hljs-built_in">_</span>&#123;uv&#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="第三步：一些优化"><a href="#第三步：一些优化" class="headerlink" title="第三步：一些优化"></a>第三步：一些优化</h4><p>UserCF看起来很简单，但有个大问题：当用户数量很大时，计算所有用户对之间的相似度会非常耗时，时间复杂度达到  $O(|U|^2)$<br>但仔细观察就会发现，很多用户对之间根本没有共同行为的物品，相似度必然为0，计算它们就是浪费时间。我们可以利用这个特点来优化算法。 </p><p>下面这个对<strong>离线计算相似度</strong>的优化的时间复杂度就不是和 u 指数级增长的了，而是和物品数成线性相关以及和每个物品被喜欢的用户数 $N(i)$ 指数级相关，虽然依然大，但是比用户指数级好的多，时间复杂度是$O(Σ|N(i)|²) ≈ O(N * k²)$，<br><strong>N</strong>  是遍历所有物品** i** ,**k <strong>是平均每个物品被喜欢的用户数，所以</strong> k² **是处理一个物品的平均计算量。</p><p>如果用<strong>R</strong>表示用户-物品的总交互数，用$\bar{n}$表示每个物品的平均用户数，公式也可以表达为$O(R \cdot \bar{n})$</p><p><strong>基于物品倒排表的优化</strong>：</p><ol><li><strong>构建倒排表</strong>：为每个物品维护一个用户列表，记录哪些用户对这个物品有过行为。这样就可以通过物品快速找到相关用户。</li><li><strong>稀疏矩阵计算</strong>：创建一个矩阵$C[u][v]$来记录用户 u 和 v 的共同物品数量。遍历每个物品的用户列表，将列表中的用户两两配对，对应的$C[u][v]$值加1。</li><li><strong>计算最终相似度</strong>：矩阵给出了余弦相似度公式的分子，再除以分母$\sqrt{|N(u)||N(v)|}$就得到了用户相似度。<br>上面说<strong>离线相似度矩阵</strong>是被推荐用户u和某用户v的，是单次计算，这个相似度矩阵要用于线上推荐，但是不能计算出所有用户对结果并全部存入矩阵拿给线上推荐，而是在离线时会存下**top k **个最相似的矩阵。</li><li><strong>线上召回</strong>：有了用户相似度矩阵，UserCF的推荐流程通常采用以下策略来提高效率：<br>收集 top k 里用户交互过的物品作为候选物品，并计算用户 u 对候选物品 i 的兴趣分数</li></ol><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">p(u, i) = <span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;v <span class="hljs-keyword">\in</span> S<span class="hljs-built_in">_</span>u <span class="hljs-keyword">\cap</span> N(i)&#125; w<span class="hljs-built_in">_</span>&#123;uv&#125; <span class="hljs-keyword">\cdot</span> r<span class="hljs-built_in">_</span>&#123;vi&#125;<br></code></pre></td></tr></table></figure><p>$S_u$是与用户 u 最相似的K个用户集合，$N(i)$是对物品 i 有过行为的用户集合，$w_{uv}$是用户相似度，$r_{vi}$表示用户对物品的兴趣强度（可以是简单的1，也可以根据评分、交互时间等设置权重）。</p><p>最终，系统对所有候选物品按兴趣分数排序，选择Top-N物品作为UserCF通道的推荐结果。这种“<strong>相似用户扩展</strong>”的方式既保证了推荐的个性化质量，又避免了对全量物品的无效计算。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu创建应用的快捷方式</title>
    <link href="/2024/10/21/ubuntu%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/10/21/ubuntu%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>在ubuntu上我们通过deb包安装的软件可能会没有快捷方式，这个时候就需要我们自己在终端上创建快捷方式了。</strong></p><p><strong>主要流程有以下几步，这里我们以go语言的IDE goland为例</strong></p><h1 id="1-创建对应的desktop文件"><a href="#1-创建对应的desktop文件" class="headerlink" title="1.创建对应的desktop文件"></a>1.创建对应的desktop文件</h1><p>比如goland，我们需要在&#x2F;usr&#x2F;share&#x2F;applications目录下创建goland.desktop</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/share/applications <br><span class="hljs-built_in">sudo</span> nano /goland.desktop<br></code></pre></td></tr></table></figure><h1 id="2-编辑这个文件"><a href="#2-编辑这个文件" class="headerlink" title="2.编辑这个文件"></a>2.编辑这个文件</h1><p>把这个文件编辑一下，记得要加sudo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> vim goland.desktop<br></code></pre></td></tr></table></figure><p>内容如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Desktop Entry]</span><br><span class="hljs-attr">Version</span>=<span class="hljs-number">1.0</span><br><span class="hljs-attr">Type</span>=Application<br><span class="hljs-attr">Name</span>=XXX  <span class="hljs-comment"># 这里输你的应用的名称</span><br><span class="hljs-attr">Exec</span>=/path/to/GoLand/bin/goland.sh  <span class="hljs-comment"># 这里输你的应用的实际路径</span><br><span class="hljs-attr">Icon</span>=/path/to/GoLand/bin/goland.png  <span class="hljs-comment"># 这里输你的应用要用的图标的路径</span><br><span class="hljs-attr">Terminal</span>=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h1 id="3-更改文件的权限"><a href="#3-更改文件的权限" class="headerlink" title="3.更改文件的权限"></a>3.更改文件的权限</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chown</span> xxx Goland.desktop  <span class="hljs-comment"># xxx是你的用户名</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> 755 Goland.desktop  <span class="hljs-comment"># 修改权限</span><br></code></pre></td></tr></table></figure><h1 id="4-把这个文件复制一份到你的桌面"><a href="#4-把这个文件复制一份到你的桌面" class="headerlink" title="4.把这个文件复制一份到你的桌面"></a>4.把这个文件复制一份到你的桌面</h1><p>用cp命令复制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> goland.desktop ~/桌面<br></code></pre></td></tr></table></figure><h1 id="5-将你桌面那个文件改为可运行"><a href="#5-将你桌面那个文件改为可运行" class="headerlink" title="5.将你桌面那个文件改为可运行"></a>5.将你桌面那个文件改为可运行</h1><p>直接右键，然后找到”允许运行”点击即可</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何在GNU/Linux下实现自己的shell</title>
    <link href="/2024/03/28/%E5%A6%82%E4%BD%95%E5%9C%A8GNU-Linux%E4%B8%8B%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84shell/"/>
    <url>/2024/03/28/%E5%A6%82%E4%BD%95%E5%9C%A8GNU-Linux%E4%B8%8B%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84shell/</url>
    
    <content type="html"><![CDATA[<h3 id="TASK"><a href="#TASK" class="headerlink" title="TASK"></a>TASK</h3><p>打造一个绝无伦比的 <code>xxx-super-shell</code> (<code>xxx</code> 是你的名字)，它能实现下面这些功能：</p><ul><li><p>实现 <strong>管道</strong> (也就是 <code>|</code>)</p></li><li><p>实现 <strong>输入输出重定向</strong>(也就是 <code>&lt;</code> <code>&gt;</code> <code>&gt;&gt;</code>)</p><ul><li>要求实现 在管道组合命令的两端实现重定向运算符</li></ul></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># Require </span><br><span class="hljs-attribute">cat</span> &lt; <span class="hljs-number">1</span>.txt | grep -C <span class="hljs-number">10</span> abc | grep -L efd | tac &gt;&gt; <span class="hljs-number">2</span>.txt<br><span class="hljs-comment"># Does not require</span><br><span class="hljs-attribute">cat</span> &lt; <span class="hljs-number">1</span>.txt | grep -C <span class="hljs-number">10</span> abc &gt; test1.txt | test2.txt &gt; grep -L efd | tac &gt;&gt; <span class="hljs-number">2</span>.txt<br></code></pre></td></tr></table></figure><ul><li><p>实现 <strong>后台运行</strong>（也就是 <code>&amp;</code> ）</p></li><li><p>实现 <strong><code>cd</code></strong>，要求支持能切换到绝对路径，相对路径和支持 <code>**cd -**</code></p></li><li><p>屏蔽一些信号（如 <code>ctrl + c</code> 不能终止）</p></li><li><p>界面美观</p></li><li><p>开发过程记录、总结、发布在个人博客中</p></li></ul><p>要求：</p><ul><li>不得出现内存泄漏，内存越界等错误</li><li>学会如何使用 gdb 进行调试，使用 valgrind 等工具进行检测</li></ul><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs elixir">xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>./xxx-super-shell<br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>echo <span class="hljs-title class_">ABCDEF</span><br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>echo <span class="hljs-title class_">ABCDEF</span> &gt; ./<span class="hljs-number">1</span>.txt<br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>cat <span class="hljs-number">1</span>.txt<br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>ls -t &gt;&gt; <span class="hljs-number">1</span>.txt<br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>ls -a -l | grep abc | wc -l &gt; <span class="hljs-number">2</span>.txt<br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>python &lt; ./<span class="hljs-number">1</span>.py | wc -c<br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>mkdir test_dir<br>xxx<span class="hljs-variable">@xxx</span> ~/test_dir <span class="hljs-variable">$ </span>cd test_dir<br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>cd -<br>xxx<span class="hljs-variable">@xxx</span> ~/test_dir <span class="hljs-variable">$ </span>cd -<br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>./xxx-super-shell <span class="hljs-comment"># shell 中嵌套 shell</span><br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>exit<br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>exit<br></code></pre></td></tr></table></figure><ul><li>核心为掌握<code>Linux系统编程</code>中<code>进程</code>的部分</li></ul><h3 id="框架主体"><a href="#框架主体" class="headerlink" title="框架主体"></a>框架主体</h3><h4 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h4><p>从main函数来分析实现的整体框架</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>  signal(SIGINT,SIG_IGN);<span class="hljs-comment">//屏蔽ctrl+c</span><br>  signal(SIGTSTP,SIG_IGN); <span class="hljs-comment">//屏蔽ctrl+z</span><br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-type">char</span>*argv[MAX]=&#123;<span class="hljs-literal">NULL</span>&#125;;<br>    printname();<br>    <span class="hljs-type">char</span>*command=readline(<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">//readline函数输出给出的字符串并读取一行输入，并为读取的输入动态分配内存，返回值为指向读取输入的指针</span><br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//屏蔽ctrl+d </span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(command) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//回车不爆栈</span><br>    <span class="hljs-type">int</span> argc=<span class="hljs-number">1</span>;  <br>    argv[<span class="hljs-number">0</span>] = strtok(command, <span class="hljs-string">&quot; &quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;argv[i] = strtok(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot; &quot;</span>);i++) argc++;<span class="hljs-comment">//将命令行输入分割为多个命令</span><br>    analyze_cmd(argc,argv);<span class="hljs-comment">//解析命令</span><br>    do_cmd(argc,argv);<span class="hljs-comment">//实现命令</span><br>    <span class="hljs-built_in">free</span>(command); <span class="hljs-comment">//释放空间</span><br>    clear_para();<span class="hljs-comment">//重置参数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一些声明如MAX可以结合文章最后的全部代码查看</li><li>首先要调用<code>signal函数</code>屏蔽一些信号</li><li>由于shell是<code>交互进程</code>，所以我们进入while(1)循环</li><li>printname函数负责每次输入命令前和后的终端名字显示和路径显示</li><li>这里使用了一个动态链接库readline,需要我们单独下载并通过相应头文件使用</li><li>整体框架已经有了，下面给出各个部分的详细解释</li></ul><h3 id="接口详解"><a href="#接口详解" class="headerlink" title="接口详解"></a>接口详解</h3><h4 id="printname"><a href="#printname" class="headerlink" title="printname()"></a>printname()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">printname</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> pathname[PATHMAX];<br>    getcwd(pathname,PATHMAX);<span class="hljs-comment">//获取当前目录</span><br>    <span class="hljs-built_in">printf</span>(BLUE<span class="hljs-string">&quot;Whosefrienda-shell&quot;</span>CLOSE);<span class="hljs-comment">//打印shell名称</span><br>    <span class="hljs-built_in">printf</span>(GREEN<span class="hljs-string">&quot; :%s&quot;</span>CLOSE,pathname);<span class="hljs-comment">//打印路径</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;$ &quot;</span>);<br>    fflush(<span class="hljs-built_in">stdout</span>);<span class="hljs-comment">//清除缓冲区</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里的BLUE和GREEN和CLOSE是通过宏定义实现的：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLUE <span class="hljs-string">&quot;\033[34m&quot;</span><span class="hljs-comment">//宏定义实现有色字体</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GREEN <span class="hljs-string">&quot;\033[32m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLOSE <span class="hljs-string">&quot;\033[0m&quot;</span></span><br></code></pre></td></tr></table></figure><h4 id="analyze-cmd-argc-argv"><a href="#analyze-cmd-argc-argv" class="headerlink" title="analyze_cmd(argc,argv)()"></a>analyze_cmd(argc,argv)()</h4><p>这里用了全局变量</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int cd <span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">;</span><br>int i_redir<span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">;</span><br>int o_redir<span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">;</span><br>int _pipe<span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">;</span><br>int a_o_redir<span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">;</span><br>int pass<span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">;//命令解析的参数</span><br></code></pre></td></tr></table></figure><h5 id="code"><a href="#code" class="headerlink" title="code"></a>code</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">analyze_cmd</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>*argv[])</span>&#123;<br>    <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;cd&quot;</span>) == <span class="hljs-number">0</span>) cd = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; argc; i++)&#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;&gt;&quot;</span>) == <span class="hljs-number">0</span>) o_redir = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;|&quot;</span>) == <span class="hljs-number">0</span>) _pipe = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;&gt;&gt;&quot;</span>) == <span class="hljs-number">0</span>) a_o_redir = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;&lt;&quot;</span>) == <span class="hljs-number">0</span>) i_redir = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;&amp;&quot;</span>) == <span class="hljs-number">0</span>)&#123;<br>        pass = <span class="hljs-number">1</span>;<br>        argv[i]=<span class="hljs-literal">NULL</span>;<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个参数都在do_cmd函数中辅助判定，从而使用不同的接口来实现命令。</p><h4 id="void-do-cmd-int-argc-char-argv"><a href="#void-do-cmd-int-argc-char-argv" class="headerlink" title="void do_cmd(int argc,char*argv[])"></a>void do_cmd(int argc,char*argv[])</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">do_cmd</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>*argv[])</span>&#123;<br>  <span class="hljs-keyword">if</span>(pass==<span class="hljs-number">1</span>) argc--;<br>  <span class="hljs-keyword">if</span> (cd == <span class="hljs-number">1</span>) mycd(argv);<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;history&quot;</span>) == <span class="hljs-number">0</span>) showhistory();<span class="hljs-comment">//展示历史命令</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;exit&quot;</span>) == <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exit\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;有停止的任务\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( i_redir== <span class="hljs-number">1</span>) iredir(argv);<span class="hljs-comment">// &lt; </span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( o_redir== <span class="hljs-number">1</span>) oredir(argv);<span class="hljs-comment">// &gt;</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( a_o_redir== <span class="hljs-number">1</span>) aoredir(argv);<span class="hljs-comment">// &gt;&gt;</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( _pipe == <span class="hljs-number">1</span>) mymulpipe(argv, argc);<span class="hljs-comment">// | 管道放在最后判定，因为重定向中也有管道的判定</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-comment">//需要fork子进程进行执行的命令</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>      perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) <span class="hljs-comment">//子进程</span><br>    &#123;<br>      execvp(argv[<span class="hljs-number">0</span>], argv);<br>      perror(<span class="hljs-string">&quot;command&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//父进程</span><br>    &#123;<br>      <span class="hljs-keyword">if</span>(pass==<span class="hljs-number">1</span>)<br>      &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,pid);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      waitpid(pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这个接口实际上通过判定参数真假值来调用其他函数来实现命令，本身只实现没有重定向和管道等的需要fork和execve的简单命令</strong></p><ul><li>这里只讲一下fork子进程实现的命令，其他在下面的具体接口再详解</li><li>fork返回两个pid值，一个是父进程的，一个是子进程的，fork后的代码会被父进程和子进程分别执行一遍，所以需要进行判定来分别编写父进程和子进程需要执行的代码</li><li>这里，子进程需要调用execvp来加载命令实现需要的代码</li><li>父进程则调用waitpid来监控子进程的进行，并且在有&amp;的情况下将控制权重新交给主函数，从而让子进程在后台执行命令的同时不影响shell前台继续执行新命令</li></ul><h4 id="void-showhistory"><a href="#void-showhistory" class="headerlink" title="void showhistory()"></a>void showhistory()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">showhistory</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  HIST_ENTRY **his;<br>  his = history_list();<br>  <span class="hljs-keyword">while</span> (his[i] != <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%-3d   %s\n&quot;</span>, i, his[i++]-&gt;line);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的HIST_ENTRY类型和history_list函数都在&lt;readline&#x2F;history.h&gt;中有定义</p><h4 id="void-mycd-char-argv"><a href="#void-mycd-char-argv" class="headerlink" title="void mycd(char *argv[])"></a>void mycd(char *argv[])</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> lastpath[MAX];<span class="hljs-comment">//为实现cd-而声明</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mycd</span><span class="hljs-params">(<span class="hljs-type">char</span> *argv[])</span>&#123;<br><span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>] == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//未输入要跳转的目录的情况</span><br>  &#123;<br>    getcwd(lastpath, <span class="hljs-keyword">sizeof</span>(lastpath));<br>    chdir(<span class="hljs-string">&quot;/home&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;-&quot;</span>) == <span class="hljs-number">0</span>)<span class="hljs-comment">//实现cd -</span><br>  &#123;<br>    <span class="hljs-type">char</span> newlastpath[MAX];<br>    getcwd(newlastpath, <span class="hljs-keyword">sizeof</span>(lastpath));<br>    chdir(lastpath);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, lastpath);<br>    <span class="hljs-built_in">strcpy</span>(lastpath, newlastpath);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;~&quot;</span>) == <span class="hljs-number">0</span>)<span class="hljs-comment">//跳转主目录</span><br>  &#123;<br>    getcwd(lastpath, <span class="hljs-keyword">sizeof</span>(lastpath));<br>    chdir(<span class="hljs-string">&quot;/home/wanggang&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    getcwd(lastpath, <span class="hljs-keyword">sizeof</span>(lastpath));<br>    chdir(argv[<span class="hljs-number">1</span>]);<span class="hljs-comment">//跳转到输入的路径名</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>为实现cd-，声明了lastpath来记录之前的路径</li><li>主要调用chdir来改变当前路径</li></ul><h4 id="void-oredir-char-argv"><a href="#void-oredir-char-argv" class="headerlink" title="void oredir(char *argv[])"></a>void oredir(char *argv[])</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">oredir</span><span class="hljs-params">(<span class="hljs-type">char</span> *argv[])</span>&#123;<br><span class="hljs-type">char</span> *preargv[MAX] = &#123;<span class="hljs-literal">NULL</span>&#125;;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;&gt;&quot;</span>))<br>  &#123;<br>    preargv[i] = argv[i];<br>    i++;<br>  &#125;<br>  <span class="hljs-type">int</span> preargc=i;<span class="hljs-comment">//重定向前面参数的个数</span><br>  i++;<br>  <span class="hljs-type">int</span> fdout = dup(<span class="hljs-number">1</span>);<span class="hljs-comment">//让标准输出获取一个新的文件描述符</span><br>  <span class="hljs-type">int</span> fd = open(argv[i], O_WRONLY | O_CREAT | O_TRUNC,<span class="hljs-number">0666</span>); <br>  dup2(fd, <span class="hljs-number">1</span>);<br>  <span class="hljs-type">pid_t</span> pid = fork();<br>  <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) <span class="hljs-comment">//子进程</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (_pipe=<span class="hljs-number">1</span>) <span class="hljs-comment">//管道&#x27;|&#x27;</span><br>    &#123;<br>      mymulpipe(preargv, preargc);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>     execvp(preargv[<span class="hljs-number">0</span>], preargv);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//父进程</span><br>  &#123;<br>     <span class="hljs-keyword">if</span>(pass==<span class="hljs-number">1</span>)<br>      &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,pid);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    waitpid(pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>  &#125;<br>  dup2(fdout, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义preargv将重定向符之前的命令保存，并获得重定向符之后的文件描述符（没有该文件就创建一个）</li><li>fork子进程运行preargv里保存的命令</li><li>最后将获得的文件描述符重定向到标准输出</li></ul><h4 id="void-mymulpipe-char-argv-int-argc"><a href="#void-mymulpipe-char-argv-int-argc" class="headerlink" title="void mymulpipe(char *argv[], int argc)"></a>void mymulpipe(char *argv[], int argc)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mymulpipe</span><span class="hljs-params">(<span class="hljs-type">char</span> *argv[], <span class="hljs-type">int</span> argc )</span>&#123;<br><span class="hljs-type">pid_t</span> pid;<br>  <span class="hljs-type">int</span> index[<span class="hljs-number">10</span>];<span class="hljs-comment">//存放每个管道的下标</span><br>  <span class="hljs-type">int</span> number=<span class="hljs-number">0</span>;<span class="hljs-comment">//统计管道个数</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;argc;i++)<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(argv[i],<span class="hljs-string">&quot;|&quot;</span>)) index[number++]=i;<br>  <span class="hljs-type">int</span> cmdcount=number+<span class="hljs-number">1</span>;<span class="hljs-comment">//命令个数</span><br>  <span class="hljs-type">char</span>* cmd[cmdcount][<span class="hljs-number">10</span>];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cmdcount;i++)<span class="hljs-comment">//将命令以管道分割存放组数组里</span><br>  &#123;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;index[i];j++)<br>      &#123;<br>        cmd[i][n++]=argv[j];<br>      &#125;<br>      cmd[i][n]=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==number)<br>    &#123;<br>      <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=index[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;j&lt;argc;j++)<br>      &#123;<br>        cmd[i][n++]=argv[j];<br>      &#125;<br>      cmd[i][n]=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>      <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=index[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;j&lt;index[i];j++)<br>      &#123;<br>        cmd[i][n++]=argv[j];<br>      &#125;<br>      cmd[i][n]=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>  &#125;<span class="hljs-comment">//命令已经分割好了，下面可以创建管道了。</span><br>  <span class="hljs-type">int</span> fd[number][<span class="hljs-number">2</span>];  <span class="hljs-comment">//存放管道的描述符</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;number;i++)<span class="hljs-comment">//循环创建多个管道</span><br>  &#123;<br>    pipe(fd[i]);<br>  &#125;<br>  <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;cmdcount;i++)<span class="hljs-comment">//父进程循环创建多个并列子进程</span><br>  &#123;<br>    pid=fork();<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)<span class="hljs-comment">//子进程退出，防止创建过多进程</span><br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)<span class="hljs-comment">//子进程</span><br>  &#123;<br>    <span class="hljs-keyword">if</span>(number)<br>    &#123;<br>      <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<span class="hljs-comment">//第一个子进程</span><br>      &#123;<br>        dup2(fd[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>],<span class="hljs-number">1</span>);<span class="hljs-comment">//绑定写端  </span><br>        close(fd[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<span class="hljs-comment">//关闭读端</span><br>        <span class="hljs-comment">//其他进程读写端全部关闭</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;number;j++)<br>        &#123;<br>          close(fd[j][<span class="hljs-number">1</span>]);<br>          close(fd[j][<span class="hljs-number">0</span>]);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==number)<span class="hljs-comment">//最后一个子进程</span><br>      &#123;<br>        dup2(fd[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],<span class="hljs-number">0</span>);<span class="hljs-comment">//打开读端</span><br>        close(fd[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);<span class="hljs-comment">//关闭写端</span><br>         <span class="hljs-comment">//其他进程读写端全部关闭</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;number<span class="hljs-number">-1</span>;j++)<br>        &#123;<br>          close(fd[j][<span class="hljs-number">1</span>]);<br>          close(fd[j][<span class="hljs-number">0</span>]);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-comment">//中间进程</span><br>      &#123;<br>        dup2(fd[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],<span class="hljs-number">0</span>);<span class="hljs-comment">//前一个管道的读端打开</span><br>        close(fd[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);<span class="hljs-comment">//前一个写端关闭</span><br>        dup2(fd[i][<span class="hljs-number">1</span>],<span class="hljs-number">1</span>);<span class="hljs-comment">//后一个管道的写端打开</span><br>        close(fd[i][<span class="hljs-number">0</span>]);<span class="hljs-comment">//后一个读端关闭</span><br>        <span class="hljs-comment">//其他的全部关闭</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;number;j++)<br>        &#123;<br>           <span class="hljs-keyword">if</span>(j!=i&amp;&amp;j!=(i<span class="hljs-number">-1</span>))<br>           &#123;<br>             close(fd[j][<span class="hljs-number">0</span>]);<br>             close(fd[j][<span class="hljs-number">1</span>]);<br>           &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br> <br>    execvp(cmd[i][<span class="hljs-number">0</span>],cmd[i]);<span class="hljs-comment">//执行命令</span><br>    perror(<span class="hljs-string">&quot;execvp&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//父进程</span><br>   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;number;i++)<br>    &#123;<br>        close(fd[i][<span class="hljs-number">0</span>]);<br>        close(fd[i][<span class="hljs-number">1</span>]);<span class="hljs-comment">//父进程端口全部关掉</span><br><br>    &#125;<br>     <span class="hljs-keyword">if</span>(pass==<span class="hljs-number">1</span>)<br>      &#123;<br>        pass=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,pid);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cmdcount;j++)<span class="hljs-comment">//父进程等待子进程</span><br>  wait(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里分两大步，第一步是通过一个二维数组将各个管道两端的命令分隔开</li><li>第二步是fork出相应数量的进程并创建相应数量的管道来执行命令</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.《Linux&#x2F;Unix系统编程手册》</p><p>2.学长的shell</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
