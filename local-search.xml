<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>推荐系统学习(一)：召回-协同过滤-UserCF</title>
    <link href="/2025/12/11/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-%E4%B8%80-%EF%BC%9A%E5%8F%AC%E5%9B%9E-%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4-UserCF/"/>
    <url>/2025/12/11/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-%E4%B8%80-%EF%BC%9A%E5%8F%AC%E5%9B%9E-%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4-UserCF/</url>
    
    <content type="html"><![CDATA[<h2 id="基于用户的协同过滤-userCF"><a href="#基于用户的协同过滤-userCF" class="headerlink" title="基于用户的协同过滤(userCF)"></a>基于用户的协同过滤(userCF)</h2><h4 id="第一步：用户相似度计算"><a href="#第一步：用户相似度计算" class="headerlink" title="第一步：用户相似度计算"></a>第一步：用户相似度计算</h4><h5 id="杰卡德相似系数"><a href="#杰卡德相似系数" class="headerlink" title="杰卡德相似系数"></a>杰卡德相似系数</h5><p>被推荐用户A，另一个用户B，只计算他们共同 item 数 占 A item 数 的比值。公式表现为：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">w<span class="hljs-built_in">_</span>&#123;uv&#125; = <span class="hljs-keyword">\frac</span>&#123;|N(u) <span class="hljs-keyword">\cap</span> N(v)|&#125;&#123;|N(u) <span class="hljs-keyword">\cup</span> N(v)|&#125;<br></code></pre></td></tr></table></figure><h5 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h5><p>通过向量化表示用户，对两个用户求向量夹角，可以体现出两个人兴趣方向是否相似，相比于杰卡德系数消除了热点造成的影响。在transformer里也有类似的求向量相似度，不过是使用比较简单的点积而非余弦。余弦相似度的公式是：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">w<span class="hljs-built_in">_</span>&#123;uv&#125; = <span class="hljs-keyword">\frac</span>&#123;|N(u) <span class="hljs-keyword">\cap</span> N(v)|&#125;&#123;<span class="hljs-keyword">\sqrt</span>&#123;|N(u)|<span class="hljs-keyword">\cdot</span>|N(v)|&#125;&#125;<br></code></pre></td></tr></table></figure><p>上面是集合形式的表达，由于喜欢，不喜欢是二元向量，所以可以如上表达，真正的余弦相似度公式是：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\text</span>&#123;similarity&#125; = <span class="hljs-keyword">\cos</span>(<span class="hljs-keyword">\theta</span>) = <span class="hljs-keyword">\frac</span>&#123;A <span class="hljs-keyword">\cdot</span> B&#125;&#123;<span class="hljs-keyword">\|</span>A<span class="hljs-keyword">\|</span> <span class="hljs-keyword">\|</span>B<span class="hljs-keyword">\|</span>&#125;<br></code></pre></td></tr></table></figure><h5 id="皮尔逊相关系数"><a href="#皮尔逊相关系数" class="headerlink" title="皮尔逊相关系数"></a>皮尔逊相关系数</h5><p>有具体评分而不是只有二元关系时使用，可以去除每个人打分标准不同导致的误差。公式：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">w<span class="hljs-built_in">_</span>&#123;uv&#125; = <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;i <span class="hljs-keyword">\in</span> I&#125;(r<span class="hljs-built_in">_</span>&#123;ui&#125; - <span class="hljs-keyword">\bar</span>&#123;r&#125;<span class="hljs-built_in">_</span>u)(r<span class="hljs-built_in">_</span>&#123;vi&#125; - <span class="hljs-keyword">\bar</span>&#123;r&#125;<span class="hljs-built_in">_</span>v)&#125;&#123;<span class="hljs-keyword">\sqrt</span>&#123;<span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;i <span class="hljs-keyword">\in</span> I&#125;(r<span class="hljs-built_in">_</span>&#123;ui&#125; - <span class="hljs-keyword">\bar</span>&#123;r&#125;<span class="hljs-built_in">_</span>u)<span class="hljs-built_in">^</span>2&#125;<span class="hljs-keyword">\sqrt</span>&#123;<span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;i <span class="hljs-keyword">\in</span> I&#125;(r<span class="hljs-built_in">_</span>&#123;vi&#125; - <span class="hljs-keyword">\bar</span>&#123;r&#125;<span class="hljs-built_in">_</span>v)<span class="hljs-built_in">^</span>2&#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="第二步：-候选物品推荐"><a href="#第二步：-候选物品推荐" class="headerlink" title="第二步： 候选物品推荐"></a>第二步： 候选物品推荐</h4><h5 id="简单加权平均"><a href="#简单加权平均" class="headerlink" title="简单加权平均"></a>简单加权平均</h5><p>直接用第一步得到的相似度来加权计算，然后多个用户的值平均，就是被推荐用户 u 对这个物品 p 的预测评分,公式：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\hat</span>&#123;r&#125;<span class="hljs-built_in">_</span>&#123;u,p&#125; = <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;v <span class="hljs-keyword">\in</span> S<span class="hljs-built_in">_</span>u&#125; w<span class="hljs-built_in">_</span>&#123;uv&#125; <span class="hljs-keyword">\,</span> r<span class="hljs-built_in">_</span>&#123;v,p&#125;&#125;&#123;<span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;v <span class="hljs-keyword">\in</span> S<span class="hljs-built_in">_</span>u&#125; w<span class="hljs-built_in">_</span>&#123;uv&#125;&#125;<br></code></pre></td></tr></table></figure><h5 id="考虑评分偏置"><a href="#考虑评分偏置" class="headerlink" title="考虑评分偏置"></a>考虑评分偏置</h5><p>考虑其他用户的平均评分来减少误差，并根据目标用户的平均评分进行调整，公式：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\hat</span>&#123;r&#125;<span class="hljs-built_in">_</span>&#123;u,p&#125; = <span class="hljs-keyword">\bar</span>&#123;r&#125;<span class="hljs-built_in">_</span>&#123;u&#125; + <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;v <span class="hljs-keyword">\in</span> S<span class="hljs-built_in">_</span>u&#125; w<span class="hljs-built_in">_</span>&#123;uv&#125; <span class="hljs-keyword">\,</span> (r<span class="hljs-built_in">_</span>&#123;v,p&#125; - <span class="hljs-keyword">\bar</span>&#123;r&#125;<span class="hljs-built_in">_</span>&#123;v&#125;)&#125;&#123;<span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;v <span class="hljs-keyword">\in</span> S<span class="hljs-built_in">_</span>u&#125; w<span class="hljs-built_in">_</span>&#123;uv&#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="第三步：一些优化"><a href="#第三步：一些优化" class="headerlink" title="第三步：一些优化"></a>第三步：一些优化</h4><p>UserCF看起来很简单，但有个大问题：当用户数量很大时，计算所有用户对之间的相似度会非常耗时，时间复杂度达到  $O(|U|^2)$<br>但仔细观察就会发现，很多用户对之间根本没有共同行为的物品，相似度必然为0，计算它们就是浪费时间。我们可以利用这个特点来优化算法。 </p><p>下面这个对<strong>离线计算相似度</strong>的优化的时间复杂度就不是和 u 指数级增长的了，而是和物品数成线性相关以及和每个物品被喜欢的用户数 $N(i)$ 指数级相关，虽然依然大，但是比用户指数级好的多，时间复杂度是$O(Σ|N(i)|²) ≈ O(N * k²)$，<br><strong>N</strong>  是遍历所有物品** i** ,**k <strong>是平均每个物品被喜欢的用户数，所以</strong> k² **是处理一个物品的平均计算量。</p><p>如果用<strong>R</strong>表示用户-物品的总交互数，用$\bar{n}$表示每个物品的平均用户数，公式也可以表达为$O(R \cdot \bar{n})$</p><p><strong>基于物品倒排表的优化</strong>：</p><ol><li><strong>构建倒排表</strong>：为每个物品维护一个用户列表，记录哪些用户对这个物品有过行为。这样就可以通过物品快速找到相关用户。</li><li><strong>稀疏矩阵计算</strong>：创建一个矩阵$C[u][v]$来记录用户 u 和 v 的共同物品数量。遍历每个物品的用户列表，将列表中的用户两两配对，对应的$C[u][v]$值加1。</li><li><strong>计算最终相似度</strong>：矩阵给出了余弦相似度公式的分子，再除以分母$\sqrt{|N(u)||N(v)|}$就得到了用户相似度。<br>上面说<strong>离线相似度矩阵</strong>是被推荐用户u和某用户v的，是单次计算，这个相似度矩阵要用于线上推荐，但是不能计算出所有用户对结果并全部存入矩阵拿给线上推荐，而是在离线时会存下**top k **个最相似的矩阵。</li><li><strong>线上召回</strong>：有了用户相似度矩阵，UserCF的推荐流程通常采用以下策略来提高效率：<br>收集 top k 里用户交互过的物品作为候选物品，并计算用户 u 对候选物品 i 的兴趣分数</li></ol><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">p(u, i) = <span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;v <span class="hljs-keyword">\in</span> S<span class="hljs-built_in">_</span>u <span class="hljs-keyword">\cap</span> N(i)&#125; w<span class="hljs-built_in">_</span>&#123;uv&#125; <span class="hljs-keyword">\cdot</span> r<span class="hljs-built_in">_</span>&#123;vi&#125;<br></code></pre></td></tr></table></figure><p>$S_u$是与用户 u 最相似的K个用户集合，$N(i)$是对物品 i 有过行为的用户集合，$w_{uv}$是用户相似度，$r_{vi}$表示用户对物品的兴趣强度（可以是简单的1，也可以根据评分、交互时间等设置权重）。</p><p>最终，系统对所有候选物品按兴趣分数排序，选择Top-N物品作为UserCF通道的推荐结果。这种“<strong>相似用户扩展</strong>”的方式既保证了推荐的个性化质量，又避免了对全量物品的无效计算。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu创建应用的快捷方式</title>
    <link href="/2024/10/21/ubuntu%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/10/21/ubuntu%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>在ubuntu上我们通过deb包安装的软件可能会没有快捷方式，这个时候就需要我们自己在终端上创建快捷方式了。</strong></p><p><strong>主要流程有以下几步，这里我们以go语言的IDE goland为例</strong></p><h1 id="1-创建对应的desktop文件"><a href="#1-创建对应的desktop文件" class="headerlink" title="1.创建对应的desktop文件"></a>1.创建对应的desktop文件</h1><p>比如goland，我们需要在&#x2F;usr&#x2F;share&#x2F;applications目录下创建goland.desktop</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/share/applications <br><span class="hljs-built_in">sudo</span> nano /goland.desktop<br></code></pre></td></tr></table></figure><h1 id="2-编辑这个文件"><a href="#2-编辑这个文件" class="headerlink" title="2.编辑这个文件"></a>2.编辑这个文件</h1><p>把这个文件编辑一下，记得要加sudo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> vim goland.desktop<br></code></pre></td></tr></table></figure><p>内容如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Desktop Entry]</span><br><span class="hljs-attr">Version</span>=<span class="hljs-number">1.0</span><br><span class="hljs-attr">Type</span>=Application<br><span class="hljs-attr">Name</span>=XXX  <span class="hljs-comment"># 这里输你的应用的名称</span><br><span class="hljs-attr">Exec</span>=/path/to/GoLand/bin/goland.sh  <span class="hljs-comment"># 这里输你的应用的实际路径</span><br><span class="hljs-attr">Icon</span>=/path/to/GoLand/bin/goland.png  <span class="hljs-comment"># 这里输你的应用要用的图标的路径</span><br><span class="hljs-attr">Terminal</span>=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h1 id="3-更改文件的权限"><a href="#3-更改文件的权限" class="headerlink" title="3.更改文件的权限"></a>3.更改文件的权限</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chown</span> xxx Goland.desktop  <span class="hljs-comment"># xxx是你的用户名</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> 755 Goland.desktop  <span class="hljs-comment"># 修改权限</span><br></code></pre></td></tr></table></figure><h1 id="4-把这个文件复制一份到你的桌面"><a href="#4-把这个文件复制一份到你的桌面" class="headerlink" title="4.把这个文件复制一份到你的桌面"></a>4.把这个文件复制一份到你的桌面</h1><p>用cp命令复制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> goland.desktop ~/桌面<br></code></pre></td></tr></table></figure><h1 id="5-将你桌面那个文件改为可运行"><a href="#5-将你桌面那个文件改为可运行" class="headerlink" title="5.将你桌面那个文件改为可运行"></a>5.将你桌面那个文件改为可运行</h1><p>直接右键，然后找到”允许运行”点击即可</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何在GNU/Linux下实现自己的shell</title>
    <link href="/2024/03/28/%E5%A6%82%E4%BD%95%E5%9C%A8GNU-Linux%E4%B8%8B%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84shell/"/>
    <url>/2024/03/28/%E5%A6%82%E4%BD%95%E5%9C%A8GNU-Linux%E4%B8%8B%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84shell/</url>
    
    <content type="html"><![CDATA[<h3 id="TASK"><a href="#TASK" class="headerlink" title="TASK"></a>TASK</h3><p>打造一个绝无伦比的 <code>xxx-super-shell</code> (<code>xxx</code> 是你的名字)，它能实现下面这些功能：</p><ul><li><p>实现 <strong>管道</strong> (也就是 <code>|</code>)</p></li><li><p>实现 <strong>输入输出重定向</strong>(也就是 <code>&lt;</code> <code>&gt;</code> <code>&gt;&gt;</code>)</p><ul><li>要求实现 在管道组合命令的两端实现重定向运算符</li></ul></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># Require </span><br><span class="hljs-attribute">cat</span> &lt; <span class="hljs-number">1</span>.txt | grep -C <span class="hljs-number">10</span> abc | grep -L efd | tac &gt;&gt; <span class="hljs-number">2</span>.txt<br><span class="hljs-comment"># Does not require</span><br><span class="hljs-attribute">cat</span> &lt; <span class="hljs-number">1</span>.txt | grep -C <span class="hljs-number">10</span> abc &gt; test1.txt | test2.txt &gt; grep -L efd | tac &gt;&gt; <span class="hljs-number">2</span>.txt<br></code></pre></td></tr></table></figure><ul><li><p>实现 <strong>后台运行</strong>（也就是 <code>&amp;</code> ）</p></li><li><p>实现 <strong><code>cd</code></strong>，要求支持能切换到绝对路径，相对路径和支持 <code>**cd -**</code></p></li><li><p>屏蔽一些信号（如 <code>ctrl + c</code> 不能终止）</p></li><li><p>界面美观</p></li><li><p>开发过程记录、总结、发布在个人博客中</p></li></ul><p>要求：</p><ul><li>不得出现内存泄漏，内存越界等错误</li><li>学会如何使用 gdb 进行调试，使用 valgrind 等工具进行检测</li></ul><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs elixir">xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>./xxx-super-shell<br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>echo <span class="hljs-title class_">ABCDEF</span><br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>echo <span class="hljs-title class_">ABCDEF</span> &gt; ./<span class="hljs-number">1</span>.txt<br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>cat <span class="hljs-number">1</span>.txt<br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>ls -t &gt;&gt; <span class="hljs-number">1</span>.txt<br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>ls -a -l | grep abc | wc -l &gt; <span class="hljs-number">2</span>.txt<br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>python &lt; ./<span class="hljs-number">1</span>.py | wc -c<br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>mkdir test_dir<br>xxx<span class="hljs-variable">@xxx</span> ~/test_dir <span class="hljs-variable">$ </span>cd test_dir<br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>cd -<br>xxx<span class="hljs-variable">@xxx</span> ~/test_dir <span class="hljs-variable">$ </span>cd -<br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>./xxx-super-shell <span class="hljs-comment"># shell 中嵌套 shell</span><br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>exit<br>xxx<span class="hljs-variable">@xxx</span> ~ <span class="hljs-variable">$ </span>exit<br></code></pre></td></tr></table></figure><ul><li>核心为掌握<code>Linux系统编程</code>中<code>进程</code>的部分</li></ul><h3 id="框架主体"><a href="#框架主体" class="headerlink" title="框架主体"></a>框架主体</h3><h4 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h4><p>从main函数来分析实现的整体框架</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>  signal(SIGINT,SIG_IGN);<span class="hljs-comment">//屏蔽ctrl+c</span><br>  signal(SIGTSTP,SIG_IGN); <span class="hljs-comment">//屏蔽ctrl+z</span><br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-type">char</span>*argv[MAX]=&#123;<span class="hljs-literal">NULL</span>&#125;;<br>    printname();<br>    <span class="hljs-type">char</span>*command=readline(<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">//readline函数输出给出的字符串并读取一行输入，并为读取的输入动态分配内存，返回值为指向读取输入的指针</span><br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//屏蔽ctrl+d </span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(command) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//回车不爆栈</span><br>    <span class="hljs-type">int</span> argc=<span class="hljs-number">1</span>;  <br>    argv[<span class="hljs-number">0</span>] = strtok(command, <span class="hljs-string">&quot; &quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;argv[i] = strtok(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot; &quot;</span>);i++) argc++;<span class="hljs-comment">//将命令行输入分割为多个命令</span><br>    analyze_cmd(argc,argv);<span class="hljs-comment">//解析命令</span><br>    do_cmd(argc,argv);<span class="hljs-comment">//实现命令</span><br>    <span class="hljs-built_in">free</span>(command); <span class="hljs-comment">//释放空间</span><br>    clear_para();<span class="hljs-comment">//重置参数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一些声明如MAX可以结合文章最后的全部代码查看</li><li>首先要调用<code>signal函数</code>屏蔽一些信号</li><li>由于shell是<code>交互进程</code>，所以我们进入while(1)循环</li><li>printname函数负责每次输入命令前和后的终端名字显示和路径显示</li><li>这里使用了一个动态链接库readline,需要我们单独下载并通过相应头文件使用</li><li>整体框架已经有了，下面给出各个部分的详细解释</li></ul><h3 id="接口详解"><a href="#接口详解" class="headerlink" title="接口详解"></a>接口详解</h3><h4 id="printname"><a href="#printname" class="headerlink" title="printname()"></a>printname()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">printname</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> pathname[PATHMAX];<br>    getcwd(pathname,PATHMAX);<span class="hljs-comment">//获取当前目录</span><br>    <span class="hljs-built_in">printf</span>(BLUE<span class="hljs-string">&quot;Whosefrienda-shell&quot;</span>CLOSE);<span class="hljs-comment">//打印shell名称</span><br>    <span class="hljs-built_in">printf</span>(GREEN<span class="hljs-string">&quot; :%s&quot;</span>CLOSE,pathname);<span class="hljs-comment">//打印路径</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;$ &quot;</span>);<br>    fflush(<span class="hljs-built_in">stdout</span>);<span class="hljs-comment">//清除缓冲区</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里的BLUE和GREEN和CLOSE是通过宏定义实现的：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLUE <span class="hljs-string">&quot;\033[34m&quot;</span><span class="hljs-comment">//宏定义实现有色字体</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GREEN <span class="hljs-string">&quot;\033[32m&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLOSE <span class="hljs-string">&quot;\033[0m&quot;</span></span><br></code></pre></td></tr></table></figure><h4 id="analyze-cmd-argc-argv"><a href="#analyze-cmd-argc-argv" class="headerlink" title="analyze_cmd(argc,argv)()"></a>analyze_cmd(argc,argv)()</h4><p>这里用了全局变量</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int cd <span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">;</span><br>int i_redir<span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">;</span><br>int o_redir<span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">;</span><br>int _pipe<span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">;</span><br>int a_o_redir<span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">;</span><br>int pass<span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">;//命令解析的参数</span><br></code></pre></td></tr></table></figure><h5 id="code"><a href="#code" class="headerlink" title="code"></a>code</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">analyze_cmd</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>*argv[])</span>&#123;<br>    <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;cd&quot;</span>) == <span class="hljs-number">0</span>) cd = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; argc; i++)&#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;&gt;&quot;</span>) == <span class="hljs-number">0</span>) o_redir = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;|&quot;</span>) == <span class="hljs-number">0</span>) _pipe = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;&gt;&gt;&quot;</span>) == <span class="hljs-number">0</span>) a_o_redir = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;&lt;&quot;</span>) == <span class="hljs-number">0</span>) i_redir = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;&amp;&quot;</span>) == <span class="hljs-number">0</span>)&#123;<br>        pass = <span class="hljs-number">1</span>;<br>        argv[i]=<span class="hljs-literal">NULL</span>;<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个参数都在do_cmd函数中辅助判定，从而使用不同的接口来实现命令。</p><h4 id="void-do-cmd-int-argc-char-argv"><a href="#void-do-cmd-int-argc-char-argv" class="headerlink" title="void do_cmd(int argc,char*argv[])"></a>void do_cmd(int argc,char*argv[])</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">do_cmd</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>*argv[])</span>&#123;<br>  <span class="hljs-keyword">if</span>(pass==<span class="hljs-number">1</span>) argc--;<br>  <span class="hljs-keyword">if</span> (cd == <span class="hljs-number">1</span>) mycd(argv);<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;history&quot;</span>) == <span class="hljs-number">0</span>) showhistory();<span class="hljs-comment">//展示历史命令</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;exit&quot;</span>) == <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exit\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;有停止的任务\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( i_redir== <span class="hljs-number">1</span>) iredir(argv);<span class="hljs-comment">// &lt; </span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( o_redir== <span class="hljs-number">1</span>) oredir(argv);<span class="hljs-comment">// &gt;</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( a_o_redir== <span class="hljs-number">1</span>) aoredir(argv);<span class="hljs-comment">// &gt;&gt;</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( _pipe == <span class="hljs-number">1</span>) mymulpipe(argv, argc);<span class="hljs-comment">// | 管道放在最后判定，因为重定向中也有管道的判定</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-comment">//需要fork子进程进行执行的命令</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>      perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) <span class="hljs-comment">//子进程</span><br>    &#123;<br>      execvp(argv[<span class="hljs-number">0</span>], argv);<br>      perror(<span class="hljs-string">&quot;command&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//父进程</span><br>    &#123;<br>      <span class="hljs-keyword">if</span>(pass==<span class="hljs-number">1</span>)<br>      &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,pid);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      waitpid(pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这个接口实际上通过判定参数真假值来调用其他函数来实现命令，本身只实现没有重定向和管道等的需要fork和execve的简单命令</strong></p><ul><li>这里只讲一下fork子进程实现的命令，其他在下面的具体接口再详解</li><li>fork返回两个pid值，一个是父进程的，一个是子进程的，fork后的代码会被父进程和子进程分别执行一遍，所以需要进行判定来分别编写父进程和子进程需要执行的代码</li><li>这里，子进程需要调用execvp来加载命令实现需要的代码</li><li>父进程则调用waitpid来监控子进程的进行，并且在有&amp;的情况下将控制权重新交给主函数，从而让子进程在后台执行命令的同时不影响shell前台继续执行新命令</li></ul><h4 id="void-showhistory"><a href="#void-showhistory" class="headerlink" title="void showhistory()"></a>void showhistory()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">showhistory</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  HIST_ENTRY **his;<br>  his = history_list();<br>  <span class="hljs-keyword">while</span> (his[i] != <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%-3d   %s\n&quot;</span>, i, his[i++]-&gt;line);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的HIST_ENTRY类型和history_list函数都在&lt;readline&#x2F;history.h&gt;中有定义</p><h4 id="void-mycd-char-argv"><a href="#void-mycd-char-argv" class="headerlink" title="void mycd(char *argv[])"></a>void mycd(char *argv[])</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> lastpath[MAX];<span class="hljs-comment">//为实现cd-而声明</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mycd</span><span class="hljs-params">(<span class="hljs-type">char</span> *argv[])</span>&#123;<br><span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>] == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//未输入要跳转的目录的情况</span><br>  &#123;<br>    getcwd(lastpath, <span class="hljs-keyword">sizeof</span>(lastpath));<br>    chdir(<span class="hljs-string">&quot;/home&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;-&quot;</span>) == <span class="hljs-number">0</span>)<span class="hljs-comment">//实现cd -</span><br>  &#123;<br>    <span class="hljs-type">char</span> newlastpath[MAX];<br>    getcwd(newlastpath, <span class="hljs-keyword">sizeof</span>(lastpath));<br>    chdir(lastpath);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, lastpath);<br>    <span class="hljs-built_in">strcpy</span>(lastpath, newlastpath);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;~&quot;</span>) == <span class="hljs-number">0</span>)<span class="hljs-comment">//跳转主目录</span><br>  &#123;<br>    getcwd(lastpath, <span class="hljs-keyword">sizeof</span>(lastpath));<br>    chdir(<span class="hljs-string">&quot;/home/wanggang&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    getcwd(lastpath, <span class="hljs-keyword">sizeof</span>(lastpath));<br>    chdir(argv[<span class="hljs-number">1</span>]);<span class="hljs-comment">//跳转到输入的路径名</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>为实现cd-，声明了lastpath来记录之前的路径</li><li>主要调用chdir来改变当前路径</li></ul><h4 id="void-oredir-char-argv"><a href="#void-oredir-char-argv" class="headerlink" title="void oredir(char *argv[])"></a>void oredir(char *argv[])</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">oredir</span><span class="hljs-params">(<span class="hljs-type">char</span> *argv[])</span>&#123;<br><span class="hljs-type">char</span> *preargv[MAX] = &#123;<span class="hljs-literal">NULL</span>&#125;;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;&gt;&quot;</span>))<br>  &#123;<br>    preargv[i] = argv[i];<br>    i++;<br>  &#125;<br>  <span class="hljs-type">int</span> preargc=i;<span class="hljs-comment">//重定向前面参数的个数</span><br>  i++;<br>  <span class="hljs-type">int</span> fdout = dup(<span class="hljs-number">1</span>);<span class="hljs-comment">//让标准输出获取一个新的文件描述符</span><br>  <span class="hljs-type">int</span> fd = open(argv[i], O_WRONLY | O_CREAT | O_TRUNC,<span class="hljs-number">0666</span>); <br>  dup2(fd, <span class="hljs-number">1</span>);<br>  <span class="hljs-type">pid_t</span> pid = fork();<br>  <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) <span class="hljs-comment">//子进程</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (_pipe=<span class="hljs-number">1</span>) <span class="hljs-comment">//管道&#x27;|&#x27;</span><br>    &#123;<br>      mymulpipe(preargv, preargc);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>     execvp(preargv[<span class="hljs-number">0</span>], preargv);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//父进程</span><br>  &#123;<br>     <span class="hljs-keyword">if</span>(pass==<span class="hljs-number">1</span>)<br>      &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,pid);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    waitpid(pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>  &#125;<br>  dup2(fdout, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义preargv将重定向符之前的命令保存，并获得重定向符之后的文件描述符（没有该文件就创建一个）</li><li>fork子进程运行preargv里保存的命令</li><li>最后将获得的文件描述符重定向到标准输出</li></ul><h4 id="void-mymulpipe-char-argv-int-argc"><a href="#void-mymulpipe-char-argv-int-argc" class="headerlink" title="void mymulpipe(char *argv[], int argc)"></a>void mymulpipe(char *argv[], int argc)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mymulpipe</span><span class="hljs-params">(<span class="hljs-type">char</span> *argv[], <span class="hljs-type">int</span> argc )</span>&#123;<br><span class="hljs-type">pid_t</span> pid;<br>  <span class="hljs-type">int</span> index[<span class="hljs-number">10</span>];<span class="hljs-comment">//存放每个管道的下标</span><br>  <span class="hljs-type">int</span> number=<span class="hljs-number">0</span>;<span class="hljs-comment">//统计管道个数</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;argc;i++)<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(argv[i],<span class="hljs-string">&quot;|&quot;</span>)) index[number++]=i;<br>  <span class="hljs-type">int</span> cmdcount=number+<span class="hljs-number">1</span>;<span class="hljs-comment">//命令个数</span><br>  <span class="hljs-type">char</span>* cmd[cmdcount][<span class="hljs-number">10</span>];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cmdcount;i++)<span class="hljs-comment">//将命令以管道分割存放组数组里</span><br>  &#123;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;index[i];j++)<br>      &#123;<br>        cmd[i][n++]=argv[j];<br>      &#125;<br>      cmd[i][n]=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==number)<br>    &#123;<br>      <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=index[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;j&lt;argc;j++)<br>      &#123;<br>        cmd[i][n++]=argv[j];<br>      &#125;<br>      cmd[i][n]=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>      <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=index[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;j&lt;index[i];j++)<br>      &#123;<br>        cmd[i][n++]=argv[j];<br>      &#125;<br>      cmd[i][n]=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>  &#125;<span class="hljs-comment">//命令已经分割好了，下面可以创建管道了。</span><br>  <span class="hljs-type">int</span> fd[number][<span class="hljs-number">2</span>];  <span class="hljs-comment">//存放管道的描述符</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;number;i++)<span class="hljs-comment">//循环创建多个管道</span><br>  &#123;<br>    pipe(fd[i]);<br>  &#125;<br>  <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;cmdcount;i++)<span class="hljs-comment">//父进程循环创建多个并列子进程</span><br>  &#123;<br>    pid=fork();<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)<span class="hljs-comment">//子进程退出，防止创建过多进程</span><br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)<span class="hljs-comment">//子进程</span><br>  &#123;<br>    <span class="hljs-keyword">if</span>(number)<br>    &#123;<br>      <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<span class="hljs-comment">//第一个子进程</span><br>      &#123;<br>        dup2(fd[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>],<span class="hljs-number">1</span>);<span class="hljs-comment">//绑定写端  </span><br>        close(fd[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<span class="hljs-comment">//关闭读端</span><br>        <span class="hljs-comment">//其他进程读写端全部关闭</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;number;j++)<br>        &#123;<br>          close(fd[j][<span class="hljs-number">1</span>]);<br>          close(fd[j][<span class="hljs-number">0</span>]);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==number)<span class="hljs-comment">//最后一个子进程</span><br>      &#123;<br>        dup2(fd[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],<span class="hljs-number">0</span>);<span class="hljs-comment">//打开读端</span><br>        close(fd[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);<span class="hljs-comment">//关闭写端</span><br>         <span class="hljs-comment">//其他进程读写端全部关闭</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;number<span class="hljs-number">-1</span>;j++)<br>        &#123;<br>          close(fd[j][<span class="hljs-number">1</span>]);<br>          close(fd[j][<span class="hljs-number">0</span>]);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-comment">//中间进程</span><br>      &#123;<br>        dup2(fd[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],<span class="hljs-number">0</span>);<span class="hljs-comment">//前一个管道的读端打开</span><br>        close(fd[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);<span class="hljs-comment">//前一个写端关闭</span><br>        dup2(fd[i][<span class="hljs-number">1</span>],<span class="hljs-number">1</span>);<span class="hljs-comment">//后一个管道的写端打开</span><br>        close(fd[i][<span class="hljs-number">0</span>]);<span class="hljs-comment">//后一个读端关闭</span><br>        <span class="hljs-comment">//其他的全部关闭</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;number;j++)<br>        &#123;<br>           <span class="hljs-keyword">if</span>(j!=i&amp;&amp;j!=(i<span class="hljs-number">-1</span>))<br>           &#123;<br>             close(fd[j][<span class="hljs-number">0</span>]);<br>             close(fd[j][<span class="hljs-number">1</span>]);<br>           &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br> <br>    execvp(cmd[i][<span class="hljs-number">0</span>],cmd[i]);<span class="hljs-comment">//执行命令</span><br>    perror(<span class="hljs-string">&quot;execvp&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//父进程</span><br>   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;number;i++)<br>    &#123;<br>        close(fd[i][<span class="hljs-number">0</span>]);<br>        close(fd[i][<span class="hljs-number">1</span>]);<span class="hljs-comment">//父进程端口全部关掉</span><br><br>    &#125;<br>     <span class="hljs-keyword">if</span>(pass==<span class="hljs-number">1</span>)<br>      &#123;<br>        pass=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,pid);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cmdcount;j++)<span class="hljs-comment">//父进程等待子进程</span><br>  wait(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里分两大步，第一步是通过一个二维数组将各个管道两端的命令分隔开</li><li>第二步是fork出相应数量的进程并创建相应数量的管道来执行命令</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.《Linux&#x2F;Unix系统编程手册》</p><p>2.学长的shell</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
